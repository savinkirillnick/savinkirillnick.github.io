### 300
вопросов, которые задают на собеседованиях по JavaScript

---

### Предисловие

Собеседование на должность JavaScript-программиста — это важный шаг для достижения ваших карьерных целей. В условиях растущего спроса на квалифицированных разработчиков и разнообразия технологий, отличная подготовка становится необходимостью. Эта книга призвана служить практическим справочником, который поможет обеим сторонам — кандидатам, готовящимся к собеседованию, и интервьюерам, оценивающим навыки соискателей.  

Структура книги тщательно разработана для максимального удобства использования. Она разделена на три основных раздела, соответствующих уровням подготовки: junior, middle и senior. Внутри каждого раздела вы найдете десять подразделов, которые охватывают самые важные аспекты JavaScript-программирования, включая основы языка, функции, объектно-ориентированное программирование, взаимодействие с DOM и множество других тем. Такой подход позволяет читателю эффективно адаптировать подготовку в зависимости от своих потребностей и уровня знаний.  

Эта книга не проста в числе вопросов и ответов; она предоставляет глубокие объяснения с практическими примерами. Мы понимаем, что некоторые темы могут быть трудными для восприятия, особенно для начинающих разработчиков, поэтому сопровождённые примерами детали помогут вам не только запомнить необходимую информацию, но и понять её суть. Например, обсуждение асинхронного программирования и коллбеков покажет вам, как правильно обрабатывать асинхронные операции, что является ключом к пониманию современных JavaScript-приложений.  

Содержание книги основано на реальном опыте прохождения собеседований, что делает её актуальной и практичной. Здесь собраны как классические вопросы, так и те, что стали популярными в последние годы, отражая современные тенденции в мире JavaScript-разработки. Читатели смогут узнать о самых последних особенностях языка, таких как ES6 и современные подходы к разработке, включая применение фреймворков и библиотек.  

Эта книга будет полезна и тем, кто готовится к собеседованию, чтобы свести к минимуму уровень стресса и уверенно демонстрировать свои знания. Интервьюеры также найдут здесь подходящие вопросы для оценки кандидатов, что поможет выбрать лучших специалистов. Ваша цель — найти работу или отобрать сильную команду — в значительной степени будет зависеть от того, насколько хорошо вы подготовлены к этому процессу.  

Я надеюсь, что этот справочник станет вашим надежным спутником на пути к успеху в мире JavaScript. Ваша уверенность, знания и умение применять их на практике помогут вам успешно пройти собеседование и достичь новых высот в карьере. Удачи в изучении JavaScript и в карьерных начинаниях!

---

### Почему JavaScript?

JavaScript — это один из самых популярных и востребованных языков программирования в мире. Изначально созданный для добавления интерактивности на веб-страницы, он превратился в универсальный инструмент, который используется как в браузере, так и на сервере (Node.js), в мобильной (React Native) и даже десктопной разработке (Electron). Если вы хотите создавать динамичные веб-приложения, JavaScript станет отличным выбором.  

Одно из главных преимуществ JavaScript — его повсеместность. Он работает в любом современном браузере без необходимости установки дополнительных программ, что делает его идеальным языком для фронтенд-разработки. Благодаря мощным фреймворкам и библиотекам (React, Vue, Angular) можно быстро создавать сложные пользовательские интерфейсы с высокой производительностью. Кроме того, JavaScript имеет огромное сообщество, что гарантирует обилие обучающих материалов, готовых решений и поддержки.  

Гибкость и простота изучения — еще одни ключевые плюсы JavaScript. Язык позволяет писать код в разных стилях (процедурный, функциональный, ООП), что делает его удобным как для новичков, так и для опытных разработчиков. При этом он постоянно развивается: новые стандарты (ECMAScript) добавляют удобные возможности, такие как стрелочные функции, деструктуризация и async/await, делая код чище и выразительнее.  

С появлением Node.js JavaScript вышел за пределы браузера и стал полноценным серверным языком. Теперь на нем можно писать бэкенд, работать с базами данных и даже создавать CLI-утилиты. Это означает, что, изучив JavaScript, вы сможете стать fullstack-разработчиком, используя один язык для всего стека технологий. Также экосистема npm (крупнейший реестр пакетов) предоставляет готовые решения практически для любых задач.  

JavaScript — это язык с большими возможностями и перспективами. Он востребован в крупных компаниях (Google, Facebook, Netflix), используется в современных технологиях (WebAssembly, Progressive Web Apps) и продолжает набирать популярность. Если вы хотите работать в веб-разработке, JavaScript открывает двери в мир высоких зарплат, интересных проектов и непрерывного профессионального роста. Начните изучать его сегодня — и вы не пожалеете!

---

### Раздел 1

### Вопросы для Junior JavaScript разработчиков

Вопросы, которые могут задать на собеседовании для **Junior JavaScript разработчика**. Они охватывают основы JavaScript, работу с DOM, асинхронность, фреймворки и другие важные темы.

---

### Часть 1. Основы JavaScript

#### Вопрос 1. Что такое JavaScript? Чем он отличается от Java?

JavaScript — это высокоуровневый, интерпретируемый язык программирования, который используется в основном для создания интерактивных веб-страниц. Он позволяет добавлять динамичное поведение, обрабатывать события, выполнять асинхронные операции и манипулировать документами HTML и CSS с помощью модели объекта документа (DOM).

**Основные отличия между Java и JavaScript**

1. **Тип языка**:
- **Java** является строго типизированным, объектно-ориентированным языком программирования, который компилируется в байт-код и запускается на Java Virtual Machine (JVM).
- **JavaScript** является динамически типизированным, интерпретируемым языком, который в первую очередь выполняется в браузере.

2. **Семантика и парадигмы**:
- **Java** Является языком объектно-ориентированного программирования. Все в Java является объектом.
- **JavaScript** Поддерживает объектно-ориентированное программирование, но также позволяет использовать и функциональный стиль.

3. **Применение**:
- **Java** чаще используется для разработки настольных приложений, серверных приложений, мобильных приложений (например, для Android) и крупных систем.
- **JavaScript** в основном используется для создания интерактивных веб-страниц, а также для серверной разработки (например, с использованием Node.js).

4. **Синтаксис**:
- **Java** требует явного объявления типов данных и строгой структуры кода.
- **JavaScript** более гибок в синтаксисе и не требует предварительного объявления типов данных.

**Примеры**:

- **Java**:
```java
public class HelloWorld {
  public static void main(String[] args) {
    System.out.println("Hello, World!");
  }
}
```

- **JavaScript**:
```javascript
console.log("Hello, World!");
```

#### Вопрос 2. Какие типы данных есть в JavaScript?

В JavaScript существует несколько основных типов данных. Они делятся на простые (примитивные) и сложные (объекты).

**Простые (примитивные) типы данных**:

1. **String (строка)**: последовательность символов.
```javascript
let name = "Alice";
```

2. **Number (число)**: как целые, так и дробные числа.
```javascript
let age = 30; // целое число
let height = 5.9; // дробное число
```

3. **Boolean (логический тип)**: принимает два значения: `true` или `false`.
```javascript
let isStudent = true;
```

4. **Undefined**: значение переменной, которой еще не присвоено значение.
```javascript
let x;
console.log(x); // выведет "undefined"
```

5. **Null**: представляет собой "пустое" значение, указывающее на отсутствие объекта.
```javascript
let y = null;
```

6. **Symbol (символ)**: уникальный и неизменяемый примитивный тип, который может быть использован как идентификатор свойств объектов (доступен начиная с ES6).
```javascript
const uniqueSymbol = Symbol('description');
```

7. **BigInt**: позволяет работать с числами произвольной длины (доступен начиная с ES11).
```javascript
const bigIntValue = BigInt(9007199254740991); // больше, чем 2^53 - 1
```

**Сложные (объектные) типы данных**

1. **Object (объект)**: коллекция свойств и методов.
```javascript
let person = {
  name: "Alice",
  age: 30,
  isStudent: false
};
```

2. **Array (массив)**: специальный тип объекта, который используется для хранения упорядоченной коллекции данных.
```javascript
let fruits = ["apple", "banana", "cherry"];
```

**Примеры использования**:

```javascript
// Пример с разными типами данных
let str = "Hello";              // строка
let num = 100;                  // число
let isActive = true;            // логический тип
let notAssigned;                // undefined
let emptyValue = null;          // null
let unique = Symbol('identifier'); // символ
let bigNumber = BigInt(12345678901234567890); // BigInt

// Объекты и массивы
let car = {                   // объект
  make: "Toyota",
  model: "Camry",
  year: 1999
};

let colors = ["red", "green", "blue"]; // массив
```

#### Вопрос 3. В чем разница между `==` и `===`?

В JavaScript существует два оператора сравнения: `==` (нестрогое равенство) и `===` (строгое равенство). Они имеют разные правила сравнения.

1. **`==` (нестрогое равенство)**

Оператор `==` сначала приводит сравниваемые значения к одному и тому же типу, а затем сравнивает их. Это может привести к неожиданным результатам, если вы не учитываете приведение типов.

**Примеры**:
```javascript
console.log(5 == '5'); // true, строка '5' преобразуется в число 5
console.log(0 == false); // true, false преобразуется в 0
console.log(null == undefined); // true, null и undefined считаются равными
```

2. **`===` (строгое равенство)**

Оператор `===` сравнивает значения без приведения типов. Это означает, что если два значения имеют разные типы, результат сравнения будет `false`.

**Примеры**:
```javascript
console.log(5 === '5'); // false, разные типы (number и string)
console.log(0 === false); // false, разные типы (number и boolean)
console.log(null === undefined); // false, разные типы (object и undefined)
```

**Резюме**

- Используйте `==`, если вам нужно сравнить значения, не обращая внимания на типы (но будьте осторожны с приведением типов).
- Используйте `===`, если необходимо проверять как значение, так и тип, что является более безопасным и предсказуемым способом сравнения.

**Рекомендуемая практика**

В общем смысле рекомендуется использовать `===` и `!==` вместо `==` и `!=`, чтобы избежать неожиданных результатов из-за неявного приведения типов.

#### Вопрос4. Что такое `NaN`? Как проверить, что значение `NaN`?

`NaN` (Not-a-Number) — это специальное значение в JavaScript, которое используется для обозначения того, что результат математической операции не является числом. Оно обычно получается в результате неудачных вычислений, таких как деление нуля на ноль или попытка преобразования нечислового значения в число.

**Примеры, когда возникает `NaN`**:

1. Деление нуля на ноль:
```javascript
let result = 0 / 0; // NaN
console.log(result); // NaN
```

2. Попытка преобразовать нечисловую строку в число:
```javascript
let value = Number("text"); // NaN
console.log(value); // NaN
```

3. Неопределенные математические операции:
```javascript
let notANumber = Math.sqrt(-1); // NaN
console.log(notANumber); // NaN
```

**Как проверить, является ли значение `NaN`?**

Проверить, является ли значение `NaN`, можно несколькими способами:

1. **Использование функции `isNaN()`**:
   Эта функция возвращает `true`, если переданное значение равно `NaN` или не может быть преобразовано в число.
```javascript
console.log(isNaN(NaN));        // true
console.log(isNaN("text"));     // true, не числовое значение
console.log(isNaN(123));        // false, это число
```

2. **Использование функции `Number.isNaN()`**:
   Эта функция более строгая и возвращает `true` только для самого значения `NaN`. Она не приводит к числу входные значения.

```javascript
console.log(Number.isNaN(NaN)); // true
console.log(Number.isNaN("text")); // false
console.log(Number.isNaN(123)); // false
console.log(Number.isNaN(undefined)); // false
```

**Рекомендуемая практика**

Используйте `Number.isNaN()` вместо `isNaN()`, если вы хотите проверить, действительно ли значение равно `NaN`, так как `isNaN()` может вернуть `true` для значений, которые не являются числами, но могут быть преобразованы в число.

#### Вопрос 5. Что такое `undefined` и `null`? В чем разница?

В JavaScript `undefined` и `null` являются двумя разными типами значений, и они используются для обозначения отсутствия значения, но в разных контекстах. Вот общее описание и примеры их использования.

**`undefined`**

`undefined` — это тип данных, который указывает на то, что переменная была объявлена, но не инициализирована, или значение не было присвоено. Это означает, что переменная существует, но у неё нет значения.

**Примеры**:
```javascript
let a;
console.log(a); // undefined, переменная объявлена, но не инициализирована

function example() {
  let b;
  console.log(b); // undefined, переменная внутри функции не инициализирована
}
example();

let obj = {};
console.log(obj.property); // undefined, свойство не существует
```

**`null`**

`null` — это явное значение, которое указывает на то, что переменная не содержит объектов или значения. Оно может быть использовано для обозначения "пустоты" или "недоступности" значения.

**Примеры**:
```javascript
let c = null;
console.log(c); // null, переменная инициализирована, но содержит значение "пустоты"

let user = {
  name: "Alice",
  age: null // возраст не задан
};
console.log(user.age); // null
```

**В чем разница?**

1. **Тип**:
- `undefined` — это тип данных, который обозначает неопределенность. Когда вы проверяете переменную с помощью `typeof`, она вернет "undefined".
- `null` — это объектный тип данных, который обозначает "пустоту" или "отсутствие объекта". При проверке типа вы получите "object".

```javascript
console.log(typeof undefined); // "undefined"
console.log(typeof null); // "object"
```

2. **Использование**:
- Используйте `undefined`, когда переменные еще не инициализированы.
- Используйте `null`, чтобы явно указать, что переменная не имеет значения или объекта.

**Резюме**

- `undefined` — значение, означающее отсутствие значения по умолчанию.
- `null` — значение, явным образом указывающее на отсутствие или пустоту значения.

#### Вопрос 6. Как проверить тип переменной?

В JavaScript есть несколько способов проверки типа переменной. Вот основные методы:

1. **`typeof` оператор**

Оператор `typeof` возвращает строку, указывающую тип переменной. Это самый распространенный способ проверки типа.

**Примеры**:
```javascript
let number = 42;
console.log(typeof number); // "number"

let str = "Hello, world!";
console.log(typeof str); // "string"

let isActive = true;
console.log(typeof isActive); // "boolean"

let obj = { name: "Alice" };
console.log(typeof obj); // "object"

let arr = [1, 2, 3];
console.log(typeof arr); // "object" (массивы также являются объектами)

let func = function() {};
console.log(typeof func); // "function"

let nullVar = null;
console.log(typeof nullVar); // "object" (это известное поведение JavaScript)

let undefinedVar;
console.log(typeof undefinedVar); // "undefined"
```

2. **`instanceof` оператор**

Оператор `instanceof` используется для проверки, является ли объект экземпляром определенного конструктора (или класса).

**Примеры**:
```javascript
let arr = [1, 2, 3];
console.log(arr instanceof Array); // true

let date = new Date();
console.log(date instanceof Date); // true

let obj = {};
console.log(obj instanceof Object); // true

let func = function() {};
console.log(func instanceof Function); // true
```

3. **`Array.isArray()`**

Этот метод позволяет проверить, является ли данный объект массивом.

**Пример**:
```javascript
let arr = [1, 2, 3];
console.log(Array.isArray(arr)); // true

let notArr = { key: "value" };
console.log(Array.isArray(notArr)); // false
```

4. **Проверка на `null`**

Для проверки, является ли переменная `null`, можно использовать строгое сравнение (`===` или `!==`):

```javascript
let value = null;
console.log(value === null); // true
```

**Резюме**

- Для базовой проверки типа переменной используйте `typeof`.
- Для проверки, является ли объект экземпляром определенного класса, используйте `instanceof`.
- Для проверки, является ли объект массивом, используйте `Array.isArray()`.
- Для проверки на `null` используйте строгое сравнение.

#### Вопрос 7. Что такое область видимости (scope)?

Область видимости (scope) в JavaScript определяет, где в коде можно обращаться к переменным. Это концепция, которая помогает контролировать доступ к переменным и функциям в различных частях программы. В JavaScript существуют три основных типа областей видимости: глобальная, функция и блочная.

1. **Глобальная область видимости**

Переменные, объявленные вне любых функций или блоков, имеют глобальную область видимости и доступны из любого места в коде.

**Пример**:
```javascript
let globalVar = "I'm a global variable";

function showGlobalVar() {
  console.log(globalVar); // Доступ к глобальной переменной
}
showGlobalVar(); // "I'm a global variable"
console.log(globalVar); // "I'm a global variable"
```

2. **Область видимости функции**

Переменные, объявленные внутри функции, имеют область видимости этой функции и недоступны вне её.

**Пример**:
```javascript
function localScope() {
  let localVar = "I'm a local variable";
  console.log(localVar); // Доступ к локальной переменной
}
localScope(); // "I'm a local variable"
console.log(localVar); // Ошибка: localVar is not defined
```

3. **Блочная область видимости**

С введением `let` и `const` в ECMAScript 6 была добавлена блочная область видимости. Переменные, объявленные с помощью `let` или `const` внутри блока (например, в фигурных скобках `{}`), доступны только в этом блоке.

**Пример**:
```javascript
if (true) {
  let blockVar = "I'm a block variable";
  console.log(blockVar); // Доступ к блочной переменной
}
console.log(blockVar); // Ошибка: blockVar is not defined
```

**Области видимости и замыкания**

Замыкания являются еще одной важной концепцией, связанной с областями видимости. Замыкание — это функция, которая захватывает переменные своей внешней (родительской) области видимости, даже когда эта внешняя функция завершила выполнение.

**Пример**:
```javascript
function outerFunction() {
  let outerVar = "I'm from the outer function";

  function innerFunction() {
    console.log(outerVar); // Доступ к внешней переменной
  }

  return innerFunction;
}

const myInnerFunction = outerFunction();
myInnerFunction(); // "I'm from the outer function"
```

**Резюме**

- Глобальная область видимости — переменные доступны в любом месте кода.
- Область видимости функции — переменные доступны только внутри функции.
- Блочная область видимости — переменные доступны только в пределах блока, где они объявлены.
- Замыкания позволяют внутренним функциям захватывать и использовать переменные из внешних областей видимости.

#### Вопрос 8. Какие есть способы объявления переменных? Чем отличаются `var`, `let`, `const`?

В JavaScript есть три основных способа объявления переменных: `var`, `let` и `const`. Каждый из этих ключевых слов имеет свои особенности и области применения. Давайте рассмотрим их подробнее.

1. **`var`**

- **Область видимости**: `var` имеет функциональную область видимости. Это означает, что если переменная объявлена внутри функции, она доступна только в этой функции. Если она объявлена вне функции, она становится глобальной.
- **Подъем (hoisting)**: Переменные, объявленные с помощью `var`, поднимаются в вверх своей области видимости, что означает, что их можно использовать до того, как они были фактически объявлены.

**Пример**:
```javascript
function varExample() {
  console.log(myVar); // undefined (подъем)
  var myVar = "I'm a var variable";
  console.log(myVar); // "I'm a var variable"
}
varExample();
```

2. **`let`**

- **Область видимости**: `let` имеет блочную область видимости. Это означает, что переменная доступна только в пределах блока, где она была объявлена, включая любые вложенные блоки.
- **Подъем**: Переменные, объявленные с помощью `let`, тоже поднимаются, но они находятся в "временной мертвой зоне" (temporal dead zone) до момента их объявления, что приводит к ошибке, если вы попытаетесь получить доступ к ним до этого момента.

**Пример**:
```javascript
function letExample() {
  if (true) {
    let myLetVar = "I'm a let variable";
    console.log(myLetVar); // "I'm a let variable"
  }
  // console.log(myLetVar); // Ошибка: myLetVar is not defined (блочная область видимости)
}
letExample();
```

3. **`const`**

- **Область видимости**: `const` также имеет блочную область видимости, как `let`.
- **Неизменяемость**: `const` предназначен для объявления переменных, значения которых не могут быть переназначены. Однако, если `const` объявляет объект или массив, его внутренние свойства могут быть изменены.
- **Подъем**: Как и `let`, переменные, объявленные с помощью `const`, имеют временную мертвую зону.

**Пример**:
```javascript
function constExample() {
  const myConstVar = "I'm a const variable";
  console.log(myConstVar); // "I'm a const variable"
  // myConstVar = "New value"; // Ошибка: Assignment to constant variable.

  const myObject = { key: "value" };
  myObject.key = "new value"; // Это допустимо
  console.log(myObject); // { key: "new value" }
}

constExample();
```

**Резюме**

- **`var`**: Область видимости функции, поднимается, может быть переопределён и заменён.
- **`let`**: Блочная область видимости, поднимается с временной мертвой зоной, может быть переопределён, но не заменён.
- **`const`**: Блочная область видимости, поднимается с временной мертвой зоной, не может быть переопределён или заменён, если это не объекты.

**Рекомендуемая практика**

Рекомендуется использовать `let` и `const` вместо `var`, чтобы избежать путаницы и обеспечить более предсказуемое поведение переменных. Используйте `let`, когда вам нужно изменять значение переменной, и `const`, когда значение переменной не должно изменяться.

#### Вопрос 9. Что такое hoisting (поднятие)?

Hoisting (поднятие) — это поведение в JavaScript, при котором объявления переменных и функций "поднимаются" к верху своей области видимости во время компиляции. Это означает, что вы можете использовать переменные и функции до их фактического объявления в коде.

**Hoisting для переменных**

При использовании `var`, объявления переменных поднимаются, но инициализация (присвоение значения) остается на своем месте. Если вы попытаетесь получить доступ к переменной до её инициализации, вы получите значение `undefined`.

**Пример с `var`**:
```javascript
console.log(myVar); // undefined (переменная будет доступна, но значение не инициализировано)
var myVar = "Hello, world!";
console.log(myVar); // "Hello, world!"
```

В этом примере, на первой строке вывода происходит поднятие, и интерпретатор видит, что переменная `myVar` была объявлена, даже если это произошло позже в коде. Поэтому он не выдает ошибку, а просто возвращает `undefined`.

**Hoisting для функций**

Функции, объявленные с помощью function declarations, также поднимаются. Вы можете вызывать функцию до её фактического объявления в коде.

**Пример**:
```javascript
console.log(myFunction()); // "Hello from function!"

function myFunction() {
  return "Hello from function!";
}
```

**Hoisting для `let` и `const`**

Переменные, объявленные с помощью `let` и `const`, также поднимаются, но они находятся в "временной мертвой зоне" (temporal dead zone) до момента их объявления. Это означает, что попытка доступа к ним до объявления приведет к ошибке.

**Пример с `let` и `const`**:
```javascript
console.log(myLetVar); // ReferenceError: Cannot access 'myLetVar' before initialization
let myLetVar = "Hello";

console.log(myConstVar); // ReferenceError: Cannot access 'myConstVar' before initialization
const myConstVar = "World";
```

**Резюме**

- Hoisting относится к поведению, при котором объявления переменных и функций поднимаются в область видимости перед выполнением кода.
- Для переменных, объявленных с `var`, значение будет `undefined` до инициализации.
- Функции, объявленные с помощью function declarations, могут быть вызваны до их фактического объявления.
- Переменные, объявленные с `let` и `const`, также поднимаются, но нельзя получить к ним доступ до их объявления, иначе это вызовет ошибку `ReferenceError`.

#### Вопрос 10. Как работают `let` и `const` в Temporal Dead Zone (TDZ)?

Temporal Dead Zone (TDZ) — это область в JavaScript, в которой переменные, объявленные с помощью `let` и `const`, существуют, но еще не инициализированы. Это означает, что вы не можете получить доступ к этим переменным до их объявления; попытка сделать это приведет к ошибке `ReferenceError`.

Давайте разберем, как `let` и `const` ведут себя в TDZ с примерами.

**Пример с `let`**

Когда переменная, объявленная с помощью `let`, вызывается до её инициализации, возникает ошибка:

```javascript
console.log(myLetVar); // ReferenceError: Cannot access 'myLetVar' before initialization
let myLetVar = "Hello";
```

В этом примере, когда мы пытаемся вывести `myLetVar` до его объявления, JavaScript видит, что переменная существует, но не инициализирована, что и приводит к ошибке.

**Пример с `const`**

Переменные, объявленные с помощью `const`, также находятся в TDZ до их инициализации. Если вы попытаетесь получить к ним доступ до этого момента, вы получите похожую ошибку:

```javascript
console.log(myConstVar); // ReferenceError: Cannot access 'myConstVar' before initialization
const myConstVar = "World";
```

Как и в случае с `let`, доступ к `myConstVar` до его объявления вызовет ошибку.

**Пример TDZ в функции**

TDZ также проявляется внутри функций. Посмотрим на следующий пример:

```javascript
function tdzExample() {
  console.log(localVar); // ReferenceError: Cannot access 'localVar' before initialization
  let localVar = "I'm in TDZ";
}

tdzExample();
```

В этом случае, при вызове функции `tdzExample`, попытка доступа к `localVar` до его объявления приводит к ошибке.

**Пример с несколькими уровнями вложенности**

Вы также можете увидеть TDZ при работе с вложенными блоками:

```javascript
{
  console.log(innerVar); // ReferenceError: Cannot access 'innerVar' before initialization
  let innerVar = "I am inside a block";
}
```

Здесь, как и прежде, мы не можем получить доступ к `innerVar` до его объявления, даже если код находится внутри блока.

**Резюме**

- **Temporal Dead Zone** (TDZ) — это область в JavaScript, где переменные, объявленные с `let` и `const`, находятся, но ещё не инициализированы.
- Попытка доступа к переменной в TDZ приводит к ошибке `ReferenceError`.
- TDZ позволяет избежать неясности при использовании переменных, так как доступ к ним до их объявления будет явно блокироваться ошибкой.

Таким образом, понимание TDZ помогает лучше управлять областями видимости и предотвращает потенциальные ошибки при работе с переменными в JavaScript.

#### Вопрос 11. Что такое замыкание (closure)?

Замыкание (closure) — это особый вид функции в JavaScript, который позволяет функции запоминать свое лексическое окружение, даже когда она вызывается вне него. Это означает, что замыкание может «захватывать» переменные своей внешней (родительской) функции и использовать их, даже если родительская функция уже завершила выполнение.

**Как работает замыкание?**

Когда функция объявляется внутри другой функции, сестра наружному контексту замыкания, сохраняется её доступ к переменным из этого контекста. Это позволяет создавать функции с приватными переменными и управлять их состоянием.

**Примеры замыкания**

1. **Простейший пример замыкания**:
```javascript
function outerFunction() {
  const outerVariable = "I'm an outer variable";

  function innerFunction() {
    console.log(outerVariable); // Доступ к внешней переменной
  }

  return innerFunction;
}

const closureFunc = outerFunction();
closureFunc(); // "I'm an outer variable"
```
В этом примере `innerFunction` замыкает переменную `outerVariable`, и вы можете получить к ней доступ, даже после того как `outerFunction` завершила выполнение.

2. **Использование замыкания для создания приватных переменных**:
```javascript
function createCounter() {
  let count = 0; // Приватная переменная

  return {
    increment: function() {
      count++;
      console.log(count);
    },
    decrement: function() {
      count--;
      console.log(count);
    },
    getCount: function() {
      return count;
    }
  };
}

const counter = createCounter();
counter.increment(); // 1
counter.increment(); // 2
console.log(counter.getCount()); // 2
counter.decrement(); // 1
```
В этом примере переменная `count` является приватной и может изменяться только через методы `increment` и `decrement`, что демонстрирует защиту данных.

3. **Замыкание как способ создания функций с параметрами**:
```javascript
function makeMultiplier(multiplier) {
  return function(x) {
    return x * multiplier;
  };
}

const double = makeMultiplier(2);
const triple = makeMultiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15
```
Здесь функция `makeMultiplier` создает замыкания с сохранением значения `multiplier`, и вы можете создать разные функции для умножения на разные значения.

**Резюме**

- **Замыкание** позволяет функции запоминать доступ к переменным из её внешнего (родительского) контекста, даже после завершения этого контекста.
- Это полезно для создания приватных переменных, управления состоянием и динамической генерации функций.

#### Вопрос 12. Как работают `call`, `apply`, `bind`?

Методы `call`, `apply` и `bind` в JavaScript используются для управления контекстом выполнения функции. Все три метода позволяют вам явно задавать значение `this`, указывая, на какой объект будет ссылаться `this` внутри функции. Однако они различаются в способе передачи аргументов. Давайте рассмотрим каждый из них подробнее.

1. **`call()`**

Метод `call()` вызывает функцию с указанным значением `this` и аргументами, переданными по отдельности.

**Синтаксис**:
```javascript
func.call(thisArg, arg1, arg2, ...);
```

**Пример**:
```javascript
function greet(greeting) {
    console.log(greeting + ", " + this.name);
}

const person = { name: "Alice" };
greet.call(person, "Hello"); // "Hello, Alice"
```
В этом примере метод `call()` вызывает функцию `greet`, устанавливая `this` в объект `person`.

2. **`apply()`**

Метод `apply()` аналогичен `call()`, но принимает второй параметр в виде массива (или массивоподобного объекта). Этот массив содержит аргументы, которые передаются в вызываемую функцию.

**Синтаксис**:
```javascript
func.apply(thisArg, [argsArray]);
```

**Пример**:
```javascript
function introduce(greeting, punctuation) {
  console.log(greeting + ", I'm " + this.name + punctuation);
}

const person = { name: "Bob" };
introduce.apply(person, ["Hi", "!"]); // "Hi, I'm Bob!"
```
В этом примере `apply()` вызывает функцию `introduce`, передавая массив аргументов.

3. **`bind()`**

Метод `bind()` создает новую функцию, которая при вызове будет иметь заданное значение `this`, а также фиксированные начальные аргументы. Это полезно, если вы хотите передать функцию с определенным контекстом в другой момент времени.

**Синтаксис**:
```javascript
const boundFunc = func.bind(thisArg, arg1, arg2, ...);
```

**Пример**:
```javascript
function greet() {
  console.log("Hello, " + this.name);
}

const person = { name: "Charlie" };
const greetPerson = greet.bind(person);
greetPerson(); // "Hello, Charlie"
```
В этом примере `bind()` создает новую функцию `greetPerson`, которая всегда будет иметь `this`, указывающее на объект `person`.

**Резюме**

- **`call()`**: вызывает функцию с заданным значением `this` и аргументами, переданными по отдельности.
- **`apply()`**: вызывает функцию с заданным значением `this` и аргументами, переданными в виде массива.
- **`bind()`**: создает новую функцию с фиксированным значением `this` и первичными аргументами, не вызывая функцию.

Эти методы позволяют эффективно управлять контекстом вызова и передавать функции с нужными данными.

#### Вопрос 13. Что такое `this`? Как определяется его значение?

`this` в JavaScript — это специальное ключевое слово, которое ссылается на текущий контекст выполнения функции. Значение `this` определяется тем, как была вызвана функция, и может меняться в зависимости от контекста. Это может вызывать путаницу, поэтому давайте разберём основные правила, определяющие, чему равен `this`.

1. **Глобальный контекст**

В глобальном контексте (вне функций) `this` ссылается на глобальный объект. В браузерах это объект `window`.

**Пример**:
```javascript
console.log(this); // В браузере: Window
```

2. **Контекст функции**

- **Обычная функция**: Если функция вызывается как обычная функция, `this` будет ссылаться на глобальный объект (`window` в браузерах) в нестром режиме. В строгом режиме (`"use strict";`) `this` будет не определён (будет равен `undefined`).

**Пример**:
```javascript
function showThis() {
  console.log(this);
}

showThis(); // В браузере: Window (нестрогий режим)
// В строгом режиме: undefined
```

3. **Контекст метода объекта**

Когда метод вызывается как свойство объекта, `this` ссылается на объект, которому принадлежит метод.

**Пример**:
```javascript
const person = {
  name: "Alice",
  greet: function() {
    console.log("Hello, " + this.name);
  }
};

person.greet(); // "Hello, Alice"
```

4. **Конструктор и `new`**

При вызове функции с помощью оператора `new` `this` ссылается на только что созданный объект.

**Пример**:
```javascript
function Person(name) {
  this.name = name;
}

const alice = new Person("Alice");
console.log(alice.name); // "Alice"
```

5. **`call` и `apply`**

Методы `call()` и `apply()` позволяют явно задавать значение `this`, когда вы вызываете функцию.

**Пример**:
```javascript
function greet() {
  console.log("Hello, " + this.name);
}

const person = { name: "Bob" };
greet.call(person); // "Hello, Bob"
```

6. **`bind`**

Метод `bind()` создаёт новую функцию, которая всегда будет иметь указанное значение `this`.

**Пример**:
```javascript
function greet() {
  console.log("Hello, " + this.name);
}

const person = { name: "Charlie" };
const greetCharlie = greet.bind(person);
greetCharlie(); // "Hello, Charlie"
```

7. **Стрелочные функции**

Стрелочные функции не имеют своего собственного значения `this`; вместо этого они захватывают значение `this` из окружающего контекста в момент их определения.

**Пример**:
```javascript
const person = {
  name: "Dave",
  greet: () => {
    console.log("Hello, " + this.name);
  }
};

person.greet(); // "Hello, undefined", поскольку `this` не указывает на `person`
```

**Резюме**

- Значение `this` в JavaScript зависит от контекста вызова функции.
- В глобальном контексте `this` ссылается на глобальный объект.
- В контексте метода объекта `this` указывает на объект, к которому принадлежит метод.
- При вызове функции с `new` `this` указывает на создаваемый объект.
- `call()`, `apply()` и `bind()` позволяют явно задавать значение `this`.
- Стрелочные функции захватывают значение `this` из окружающего контекста.

#### Вопрос 14. Что такое стрелочные функции? Чем отличаются от обычных?

Стрелочные функции (или arrow functions) — это синтаксический сахар для объявления функций в JavaScript, введённый в ES6 (ECMAScript 2015). Они позволяют более лаконично записывать функции, особенно для коротких и однофункционных выражений.

**Основные особенности стрелочных функций**

1. **Синтаксис**: Стрелочные функции имеют более короткий и удобный синтаксис по сравнению с обычными функциями.

**Пример**:
```javascript
// Обычная функция
function add(a, b) {
   return a + b;
}

// Стрелочная функция
const addArrow = (a, b) => a + b;
```

2. **Отсутствие собственного `this`**: Одной из самых больших особенностей стрелочных функций является то, что они не имеют своего собственного значения `this`. Вместо этого `this` наследуется из внешнего (родительского) контекста, в котором была объявлена стрелочная функция. Это делает их особенно полезными при работе с методами объектов и обработчиками событий.

**Пример**:
```javascript
const person = {
  name: "Alice",
  greet: function() {
    setTimeout(() => {
      console.log("Hello, " + this.name); // `this` указывает на `person`
      }, 1000);
   }
};

person.greet(); // "Hello, Alice" через 1 секунду
```

3. **Невозможность использования в качестве конструктора**: Стрелочные функции не могут быть вызваны с использованием оператора `new`. Это означает, что их нельзя использовать для создания объектов.

**Пример**:
```javascript
const Person = (name) => {
  this.name = name; // Не будет работать так, как ожидается
};

const john = new Person("John"); // TypeError: Person is not a constructor
```

4. **Отсутствие своего `arguments`**: Стрелочные функции не имеют собственных параметров `arguments`. Однако вы можете использовать оператор расширения `...` для этого.

**Пример**:
```javascript
const multiply = (...args) => {
  return args.reduce((acc, curr) => acc * curr, 1);
};

console.log(multiply(2, 3, 4)); // 24
```

5. **Краткий синтаксис для однофункционных выражений**: Если тело стрелочной функции состоит из единственного выражения, вы можете опустить фигурные скобки и оператор `return`.

**Пример**:
```javascript
const square = x => x * x;
console.log(square(4)); // 16
```

**Резюме**

- **Синтаксис**: Простое и краткое объявление функций.
- **Отсутствие собственного `this`**: `this` захватывается из внешнего контекста.
- **Невозможность использования в качестве конструктора**.
- **Отсутствие собственного `arguments`**: Можно использовать оператор расширения.
- **Краткий синтаксис**: Можно опустить фигурные скобки и `return` для однострочных выражений.

Стрелочные функции часто используются, чтобы сделать код более читабельным и избежать проблем с контекстом вызова `this`.

#### Вопрос 15. Что такое IIFE (Immediately Invoked Function Expression)?

IIFE (Immediately Invoked Function Expression) — это функция, которая определяется и вызывается немедленно после её создания. Это позволяет создавать новый контекст выполнения, изолируя переменные и функции внутри, что помогает избежать конфликтов с другими переменными в глобальной области видимости.

**Синтаксис IIFE**

IIFE обычно записывается в виде анонимной функции, обёрнутой в круглые скобки, за которой следует пара круглых скобок для немедленного вызова. Вот общий синтаксис:

```javascript
(function() {
  // Код выполняется немедленно
})();
```

Если нужна функция с аргументами, синтаксис выглядит следующим образом:

```javascript
(function(arg1, arg2) {
  // Код выполняется немедленно
})(value1, value2);
```

**Примеры IIFE**

1. **Простой пример**:

```javascript
(function() {
  console.log("Hello, World!");
})();
```
В этом примере анонимная функция выполняется сразу же, и выводит "Hello, World!" в консоль.

2. **Создание изолированной области видимости**:

```javascript
var globalVar = "I'm global";

(function() {
  var localVar = "I'm local";
  console.log(localVar); // "I'm local"
})();

console.log(globalVar); // "I'm global"
// console.log(localVar); // ReferenceError: localVar is not defined
```
Здесь переменная `localVar` находится в локальной области видимости и недоступна из глобального контекста. Таким образом, IIFE позволяет защитить переменные от загрязнения глобальной области видимости.

3. **Приём для создания модулей**:

IIFE часто используется для создания модулей и управления видимостью переменных.

```javascript
var counter = (function() {
  var count = 0;

  return {
    increment: function() {
      count++;
      console.log(count);
    },
    decrement: function() {
      count--;
      console.log(count);
    },
    getCount: function() {
      return count;
    }
  };
})();

counter.increment(); // 1
counter.increment(); // 2
console.log(counter.getCount()); // 2
counter.decrement(); // 1
```
В этом примере IIFE создаёт модуль `counter`, который инкапсулирует переменную `count`, обеспечивая доступ к методам для её изменения, но не позволяя пользователю напрямую получать или изменять `count`.

**Резюме**

- **IIFE** позволяет немедленно вызвать функцию после её объявления.
- Он создаёт изолированную область видимости, что помогает избежать загрязнения глобального пространства имён.
- Часто используется для создания модулей и управления видимостью переменных при разработке более сложных приложений.



