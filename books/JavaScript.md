### 300
вопросов, которые задают на собеседованиях по JavaScript

---

### Предисловие

Собеседование на должность JavaScript-программиста — это важный шаг для достижения ваших карьерных целей. В условиях растущего спроса на квалифицированных разработчиков и разнообразия технологий, отличная подготовка становится необходимостью. Эта книга призвана служить практическим справочником, который поможет обеим сторонам — кандидатам, готовящимся к собеседованию, и интервьюерам, оценивающим навыки соискателей.  

Структура книги тщательно разработана для максимального удобства использования. Она разделена на три основных раздела, соответствующих уровням подготовки: junior, middle и senior. Внутри каждого раздела вы найдете десять подразделов, которые охватывают самые важные аспекты JavaScript-программирования, включая основы языка, функции, объектно-ориентированное программирование, взаимодействие с DOM и множество других тем. Такой подход позволяет читателю эффективно адаптировать подготовку в зависимости от своих потребностей и уровня знаний.  

Эта книга не проста в числе вопросов и ответов; она предоставляет глубокие объяснения с практическими примерами. Мы понимаем, что некоторые темы могут быть трудными для восприятия, особенно для начинающих разработчиков, поэтому сопровождённые примерами детали помогут вам не только запомнить необходимую информацию, но и понять её суть. Например, обсуждение асинхронного программирования и коллбеков покажет вам, как правильно обрабатывать асинхронные операции, что является ключом к пониманию современных JavaScript-приложений.  

Содержание книги основано на реальном опыте прохождения собеседований, что делает её актуальной и практичной. Здесь собраны как классические вопросы, так и те, что стали популярными в последние годы, отражая современные тенденции в мире JavaScript-разработки. Читатели смогут узнать о самых последних особенностях языка, таких как ES6 и современные подходы к разработке, включая применение фреймворков и библиотек.  

Эта книга будет полезна и тем, кто готовится к собеседованию, чтобы свести к минимуму уровень стресса и уверенно демонстрировать свои знания. Интервьюеры также найдут здесь подходящие вопросы для оценки кандидатов, что поможет выбрать лучших специалистов. Ваша цель — найти работу или отобрать сильную команду — в значительной степени будет зависеть от того, насколько хорошо вы подготовлены к этому процессу.  

Я надеюсь, что этот справочник станет вашим надежным спутником на пути к успеху в мире JavaScript. Ваша уверенность, знания и умение применять их на практике помогут вам успешно пройти собеседование и достичь новых высот в карьере. Удачи в изучении JavaScript и в карьерных начинаниях!

---

### Почему JavaScript?

JavaScript — это один из самых популярных и востребованных языков программирования в мире. Изначально созданный для добавления интерактивности на веб-страницы, он превратился в универсальный инструмент, который используется как в браузере, так и на сервере (Node.js), в мобильной (React Native) и даже десктопной разработке (Electron). Если вы хотите создавать динамичные веб-приложения, JavaScript станет отличным выбором.  

Одно из главных преимуществ JavaScript — его повсеместность. Он работает в любом современном браузере без необходимости установки дополнительных программ, что делает его идеальным языком для фронтенд-разработки. Благодаря мощным фреймворкам и библиотекам (React, Vue, Angular) можно быстро создавать сложные пользовательские интерфейсы с высокой производительностью. Кроме того, JavaScript имеет огромное сообщество, что гарантирует обилие обучающих материалов, готовых решений и поддержки.  

Гибкость и простота изучения — еще одни ключевые плюсы JavaScript. Язык позволяет писать код в разных стилях (процедурный, функциональный, ООП), что делает его удобным как для новичков, так и для опытных разработчиков. При этом он постоянно развивается: новые стандарты (ECMAScript) добавляют удобные возможности, такие как стрелочные функции, деструктуризация и async/await, делая код чище и выразительнее.  

С появлением Node.js JavaScript вышел за пределы браузера и стал полноценным серверным языком. Теперь на нем можно писать бэкенд, работать с базами данных и даже создавать CLI-утилиты. Это означает, что, изучив JavaScript, вы сможете стать fullstack-разработчиком, используя один язык для всего стека технологий. Также экосистема npm (крупнейший реестр пакетов) предоставляет готовые решения практически для любых задач.  

JavaScript — это язык с большими возможностями и перспективами. Он востребован в крупных компаниях (Google, Facebook, Netflix), используется в современных технологиях (WebAssembly, Progressive Web Apps) и продолжает набирать популярность. Если вы хотите работать в веб-разработке, JavaScript открывает двери в мир высоких зарплат, интересных проектов и непрерывного профессионального роста. Начните изучать его сегодня — и вы не пожалеете!

---

### Раздел 1

### Вопросы для Junior JavaScript разработчиков

Вопросы, которые могут задать на собеседовании для **Junior JavaScript разработчика**. Они охватывают основы JavaScript, работу с DOM, асинхронность, фреймворки и другие важные темы.

---

### Часть 1. Основы JavaScript

#### Вопрос 1. Что такое JavaScript? Чем он отличается от Java?

JavaScript — это высокоуровневый, интерпретируемый язык программирования, который используется в основном для создания интерактивных веб-страниц. Он позволяет добавлять динамичное поведение, обрабатывать события, выполнять асинхронные операции и манипулировать документами HTML и CSS с помощью модели объекта документа (DOM).

**Основные отличия между Java и JavaScript**

1. **Тип языка**:
- **Java** является строго типизированным, объектно-ориентированным языком программирования, который компилируется в байт-код и запускается на Java Virtual Machine (JVM).
- **JavaScript** является динамически типизированным, интерпретируемым языком, который в первую очередь выполняется в браузере.

2. **Семантика и парадигмы**:
- **Java** Является языком объектно-ориентированного программирования. Все в Java является объектом.
- **JavaScript** Поддерживает объектно-ориентированное программирование, но также позволяет использовать и функциональный стиль.

3. **Применение**:
- **Java** чаще используется для разработки настольных приложений, серверных приложений, мобильных приложений (например, для Android) и крупных систем.
- **JavaScript** в основном используется для создания интерактивных веб-страниц, а также для серверной разработки (например, с использованием Node.js).

4. **Синтаксис**:
- **Java** требует явного объявления типов данных и строгой структуры кода.
- **JavaScript** более гибок в синтаксисе и не требует предварительного объявления типов данных.

**Примеры**:

- **Java**:
```java
public class HelloWorld {
  public static void main(String[] args) {
    System.out.println("Hello, World!");
  }
}
```

- **JavaScript**:
```javascript
console.log("Hello, World!");
```

#### Вопрос 2. Какие типы данных есть в JavaScript?

В JavaScript существует несколько основных типов данных. Они делятся на простые (примитивные) и сложные (объекты).

**Простые (примитивные) типы данных**:

1. **String (строка)**: последовательность символов.
```javascript
let name = "Alice";
```

2. **Number (число)**: как целые, так и дробные числа.
```javascript
let age = 30; // целое число
let height = 5.9; // дробное число
```

3. **Boolean (логический тип)**: принимает два значения: `true` или `false`.
```javascript
let isStudent = true;
```

4. **Undefined**: значение переменной, которой еще не присвоено значение.
```javascript
let x;
console.log(x); // выведет "undefined"
```

5. **Null**: представляет собой "пустое" значение, указывающее на отсутствие объекта.
```javascript
let y = null;
```

6. **Symbol (символ)**: уникальный и неизменяемый примитивный тип, который может быть использован как идентификатор свойств объектов (доступен начиная с ES6).
```javascript
const uniqueSymbol = Symbol('description');
```

7. **BigInt**: позволяет работать с числами произвольной длины (доступен начиная с ES11).
```javascript
const bigIntValue = BigInt(9007199254740991); // больше, чем 2^53 - 1
```

**Сложные (объектные) типы данных**

1. **Object (объект)**: коллекция свойств и методов.
```javascript
let person = {
  name: "Alice",
  age: 30,
  isStudent: false
};
```

2. **Array (массив)**: специальный тип объекта, который используется для хранения упорядоченной коллекции данных.
```javascript
let fruits = ["apple", "banana", "cherry"];
```

**Примеры использования**:

```javascript
// Пример с разными типами данных
let str = "Hello";              // строка
let num = 100;                  // число
let isActive = true;            // логический тип
let notAssigned;                // undefined
let emptyValue = null;          // null
let unique = Symbol('identifier'); // символ
let bigNumber = BigInt(12345678901234567890); // BigInt

// Объекты и массивы
let car = {                   // объект
  make: "Toyota",
  model: "Camry",
  year: 1999
};

let colors = ["red", "green", "blue"]; // массив
```

#### Вопрос 3. В чем разница между `==` и `===`?

В JavaScript существует два оператора сравнения: `==` (нестрогое равенство) и `===` (строгое равенство). Они имеют разные правила сравнения.

1. **`==` (нестрогое равенство)**

Оператор `==` сначала приводит сравниваемые значения к одному и тому же типу, а затем сравнивает их. Это может привести к неожиданным результатам, если вы не учитываете приведение типов.

**Примеры**:
```javascript
console.log(5 == '5'); // true, строка '5' преобразуется в число 5
console.log(0 == false); // true, false преобразуется в 0
console.log(null == undefined); // true, null и undefined считаются равными
```

2. **`===` (строгое равенство)**

Оператор `===` сравнивает значения без приведения типов. Это означает, что если два значения имеют разные типы, результат сравнения будет `false`.

**Примеры**:
```javascript
console.log(5 === '5'); // false, разные типы (number и string)
console.log(0 === false); // false, разные типы (number и boolean)
console.log(null === undefined); // false, разные типы (object и undefined)
```

**Резюме**

- Используйте `==`, если вам нужно сравнить значения, не обращая внимания на типы (но будьте осторожны с приведением типов).
- Используйте `===`, если необходимо проверять как значение, так и тип, что является более безопасным и предсказуемым способом сравнения.

**Рекомендуемая практика**

В общем смысле рекомендуется использовать `===` и `!==` вместо `==` и `!=`, чтобы избежать неожиданных результатов из-за неявного приведения типов.

#### Вопрос4. Что такое `NaN`? Как проверить, что значение `NaN`?

`NaN` (Not-a-Number) — это специальное значение в JavaScript, которое используется для обозначения того, что результат математической операции не является числом. Оно обычно получается в результате неудачных вычислений, таких как деление нуля на ноль или попытка преобразования нечислового значения в число.

**Примеры, когда возникает `NaN`**:

1. Деление нуля на ноль:
```javascript
let result = 0 / 0; // NaN
console.log(result); // NaN
```

2. Попытка преобразовать нечисловую строку в число:
```javascript
let value = Number("text"); // NaN
console.log(value); // NaN
```

3. Неопределенные математические операции:
```javascript
let notANumber = Math.sqrt(-1); // NaN
console.log(notANumber); // NaN
```

**Как проверить, является ли значение `NaN`?**

Проверить, является ли значение `NaN`, можно несколькими способами:

1. **Использование функции `isNaN()`**:
   Эта функция возвращает `true`, если переданное значение равно `NaN` или не может быть преобразовано в число.
```javascript
console.log(isNaN(NaN));        // true
console.log(isNaN("text"));     // true, не числовое значение
console.log(isNaN(123));        // false, это число
```

2. **Использование функции `Number.isNaN()`**:
   Эта функция более строгая и возвращает `true` только для самого значения `NaN`. Она не приводит к числу входные значения.

```javascript
console.log(Number.isNaN(NaN)); // true
console.log(Number.isNaN("text")); // false
console.log(Number.isNaN(123)); // false
console.log(Number.isNaN(undefined)); // false
```

**Рекомендуемая практика**

Используйте `Number.isNaN()` вместо `isNaN()`, если вы хотите проверить, действительно ли значение равно `NaN`, так как `isNaN()` может вернуть `true` для значений, которые не являются числами, но могут быть преобразованы в число.

#### Вопрос 5. Что такое `undefined` и `null`? В чем разница?

В JavaScript `undefined` и `null` являются двумя разными типами значений, и они используются для обозначения отсутствия значения, но в разных контекстах. Вот общее описание и примеры их использования.

1. **`undefined`**

`undefined` — это тип данных, который указывает на то, что переменная была объявлена, но не инициализирована, или значение не было присвоено. Это означает, что переменная существует, но у неё нет значения.

**Примеры**:
```javascript
let a;
console.log(a); // undefined, переменная объявлена, но не инициализирована

function example() {
  let b;
  console.log(b); // undefined, переменная внутри функции не инициализирована
}
example();

let obj = {};
console.log(obj.property); // undefined, свойство не существует
```

2. **`null`**

`null` — это явное значение, которое указывает на то, что переменная не содержит объектов или значения. Оно может быть использовано для обозначения "пустоты" или "недоступности" значения.

**Примеры**:
```javascript
let c = null;
console.log(c); // null, переменная инициализирована, но содержит значение "пустоты"

let user = {
  name: "Alice",
  age: null // возраст не задан
};
console.log(user.age); // null
```

**В чем разница?**

1. **Тип**:
- `undefined` — это тип данных, который обозначает неопределенность. Когда вы проверяете переменную с помощью `typeof`, она вернет "undefined".
- `null` — это объектный тип данных, который обозначает "пустоту" или "отсутствие объекта". При проверке типа вы получите "object".

```javascript
console.log(typeof undefined); // "undefined"
console.log(typeof null); // "object"
```

2. **Использование**:
- Используйте `undefined`, когда переменные еще не инициализированы.
- Используйте `null`, чтобы явно указать, что переменная не имеет значения или объекта.

**Резюме**

- `undefined` — значение, означающее отсутствие значения по умолчанию.
- `null` — значение, явным образом указывающее на отсутствие или пустоту значения.

#### Вопрос 6. Как проверить тип переменной?

В JavaScript есть несколько способов проверки типа переменной. Вот основные методы:

1. **`typeof` оператор**

Оператор `typeof` возвращает строку, указывающую тип переменной. Это самый распространенный способ проверки типа.

**Примеры**:
```javascript
let number = 42;
console.log(typeof number); // "number"

let str = "Hello, world!";
console.log(typeof str); // "string"

let isActive = true;
console.log(typeof isActive); // "boolean"

let obj = { name: "Alice" };
console.log(typeof obj); // "object"

let arr = [1, 2, 3];
console.log(typeof arr); // "object" (массивы также являются объектами)

let func = function() {};
console.log(typeof func); // "function"

let nullVar = null;
console.log(typeof nullVar); // "object" (это известное поведение JavaScript)

let undefinedVar;
console.log(typeof undefinedVar); // "undefined"
```

2. **`instanceof` оператор**

Оператор `instanceof` используется для проверки, является ли объект экземпляром определенного конструктора (или класса).

**Примеры**:
```javascript
let arr = [1, 2, 3];
console.log(arr instanceof Array); // true

let date = new Date();
console.log(date instanceof Date); // true

let obj = {};
console.log(obj instanceof Object); // true

let func = function() {};
console.log(func instanceof Function); // true
```

3. **`Array.isArray()`**

Этот метод позволяет проверить, является ли данный объект массивом.

**Пример**:
```javascript
let arr = [1, 2, 3];
console.log(Array.isArray(arr)); // true

let notArr = { key: "value" };
console.log(Array.isArray(notArr)); // false
```

4. **Проверка на `null`**

Для проверки, является ли переменная `null`, можно использовать строгое сравнение (`===` или `!==`):

```javascript
let value = null;
console.log(value === null); // true
```

**Резюме**

- Для базовой проверки типа переменной используйте `typeof`.
- Для проверки, является ли объект экземпляром определенного класса, используйте `instanceof`.
- Для проверки, является ли объект массивом, используйте `Array.isArray()`.
- Для проверки на `null` используйте строгое сравнение.

#### Вопрос 7. Что такое область видимости (scope)?

Область видимости (scope) в JavaScript определяет, где в коде можно обращаться к переменным. Это концепция, которая помогает контролировать доступ к переменным и функциям в различных частях программы. В JavaScript существуют три основных типа областей видимости: глобальная, функция и блочная.

1. **Глобальная область видимости**

Переменные, объявленные вне любых функций или блоков, имеют глобальную область видимости и доступны из любого места в коде.

**Пример**:
```javascript
let globalVar = "I'm a global variable";

function showGlobalVar() {
  console.log(globalVar); // Доступ к глобальной переменной
}
showGlobalVar(); // "I'm a global variable"
console.log(globalVar); // "I'm a global variable"
```

2. **Область видимости функции**

Переменные, объявленные внутри функции, имеют область видимости этой функции и недоступны вне её.

**Пример**:
```javascript
function localScope() {
  let localVar = "I'm a local variable";
  console.log(localVar); // Доступ к локальной переменной
}
localScope(); // "I'm a local variable"
console.log(localVar); // Ошибка: localVar is not defined
```

3. **Блочная область видимости**

С введением `let` и `const` в ECMAScript 6 была добавлена блочная область видимости. Переменные, объявленные с помощью `let` или `const` внутри блока (например, в фигурных скобках `{}`), доступны только в этом блоке.

**Пример**:
```javascript
if (true) {
  let blockVar = "I'm a block variable";
  console.log(blockVar); // Доступ к блочной переменной
}
console.log(blockVar); // Ошибка: blockVar is not defined
```

**Области видимости и замыкания**

Замыкания являются еще одной важной концепцией, связанной с областями видимости. Замыкание — это функция, которая захватывает переменные своей внешней (родительской) области видимости, даже когда эта внешняя функция завершила выполнение.

**Пример**:
```javascript
function outerFunction() {
  let outerVar = "I'm from the outer function";

  function innerFunction() {
    console.log(outerVar); // Доступ к внешней переменной
  }

  return innerFunction;
}

const myInnerFunction = outerFunction();
myInnerFunction(); // "I'm from the outer function"
```

**Резюме**

- Глобальная область видимости — переменные доступны в любом месте кода.
- Область видимости функции — переменные доступны только внутри функции.
- Блочная область видимости — переменные доступны только в пределах блока, где они объявлены.
- Замыкания позволяют внутренним функциям захватывать и использовать переменные из внешних областей видимости.

#### Вопрос 8. Какие есть способы объявления переменных? Чем отличаются `var`, `let`, `const`?

В JavaScript есть три основных способа объявления переменных: `var`, `let` и `const`. Каждый из этих ключевых слов имеет свои особенности и области применения. Давайте рассмотрим их подробнее.

1. **`var`**

- **Область видимости**: `var` имеет функциональную область видимости. Это означает, что если переменная объявлена внутри функции, она доступна только в этой функции. Если она объявлена вне функции, она становится глобальной.
- **Подъем (hoisting)**: Переменные, объявленные с помощью `var`, поднимаются в вверх своей области видимости, что означает, что их можно использовать до того, как они были фактически объявлены.

**Пример**:
```javascript
function varExample() {
  console.log(myVar); // undefined (подъем)
  var myVar = "I'm a var variable";
  console.log(myVar); // "I'm a var variable"
}
varExample();
```

2. **`let`**

- **Область видимости**: `let` имеет блочную область видимости. Это означает, что переменная доступна только в пределах блока, где она была объявлена, включая любые вложенные блоки.
- **Подъем**: Переменные, объявленные с помощью `let`, тоже поднимаются, но они находятся в "временной мертвой зоне" (temporal dead zone) до момента их объявления, что приводит к ошибке, если вы попытаетесь получить доступ к ним до этого момента.

**Пример**:
```javascript
function letExample() {
  if (true) {
    let myLetVar = "I'm a let variable";
    console.log(myLetVar); // "I'm a let variable"
  }
  // console.log(myLetVar); // Ошибка: myLetVar is not defined (блочная область видимости)
}
letExample();
```

3. **`const`**

- **Область видимости**: `const` также имеет блочную область видимости, как `let`.
- **Неизменяемость**: `const` предназначен для объявления переменных, значения которых не могут быть переназначены. Однако, если `const` объявляет объект или массив, его внутренние свойства могут быть изменены.
- **Подъем**: Как и `let`, переменные, объявленные с помощью `const`, имеют временную мертвую зону.

**Пример**:
```javascript
function constExample() {
  const myConstVar = "I'm a const variable";
  console.log(myConstVar); // "I'm a const variable"
  // myConstVar = "New value"; // Ошибка: Assignment to constant variable.

  const myObject = { key: "value" };
  myObject.key = "new value"; // Это допустимо
  console.log(myObject); // { key: "new value" }
}

constExample();
```

**Резюме**

- **`var`**: Область видимости функции, поднимается, может быть переопределён и заменён.
- **`let`**: Блочная область видимости, поднимается с временной мертвой зоной, может быть переопределён, но не заменён.
- **`const`**: Блочная область видимости, поднимается с временной мертвой зоной, не может быть переопределён или заменён, если это не объекты.

**Рекомендуемая практика**

Рекомендуется использовать `let` и `const` вместо `var`, чтобы избежать путаницы и обеспечить более предсказуемое поведение переменных. Используйте `let`, когда вам нужно изменять значение переменной, и `const`, когда значение переменной не должно изменяться.

#### Вопрос 9. Что такое hoisting (поднятие)?

Hoisting (поднятие) — это поведение в JavaScript, при котором объявления переменных и функций "поднимаются" к верху своей области видимости во время компиляции. Это означает, что вы можете использовать переменные и функции до их фактического объявления в коде.

**Hoisting для переменных**

При использовании `var`, объявления переменных поднимаются, но инициализация (присвоение значения) остается на своем месте. Если вы попытаетесь получить доступ к переменной до её инициализации, вы получите значение `undefined`.

**Пример с `var`**:
```javascript
console.log(myVar); // undefined (переменная будет доступна, но значение не инициализировано)
var myVar = "Hello, world!";
console.log(myVar); // "Hello, world!"
```

В этом примере, на первой строке вывода происходит поднятие, и интерпретатор видит, что переменная `myVar` была объявлена, даже если это произошло позже в коде. Поэтому он не выдает ошибку, а просто возвращает `undefined`.

**Hoisting для функций**

Функции, объявленные с помощью function declarations, также поднимаются. Вы можете вызывать функцию до её фактического объявления в коде.

**Пример**:
```javascript
console.log(myFunction()); // "Hello from function!"

function myFunction() {
  return "Hello from function!";
}
```

**Hoisting для `let` и `const`**

Переменные, объявленные с помощью `let` и `const`, также поднимаются, но они находятся в "временной мертвой зоне" (temporal dead zone) до момента их объявления. Это означает, что попытка доступа к ним до объявления приведет к ошибке.

**Пример с `let` и `const`**:
```javascript
console.log(myLetVar); // ReferenceError: Cannot access 'myLetVar' before initialization
let myLetVar = "Hello";

console.log(myConstVar); // ReferenceError: Cannot access 'myConstVar' before initialization
const myConstVar = "World";
```

**Резюме**

- Hoisting относится к поведению, при котором объявления переменных и функций поднимаются в область видимости перед выполнением кода.
- Для переменных, объявленных с `var`, значение будет `undefined` до инициализации.
- Функции, объявленные с помощью function declarations, могут быть вызваны до их фактического объявления.
- Переменные, объявленные с `let` и `const`, также поднимаются, но нельзя получить к ним доступ до их объявления, иначе это вызовет ошибку `ReferenceError`.

#### Вопрос 10. Как работают `let` и `const` в Temporal Dead Zone (TDZ)?

Temporal Dead Zone (TDZ) — это область в JavaScript, в которой переменные, объявленные с помощью `let` и `const`, существуют, но еще не инициализированы. Это означает, что вы не можете получить доступ к этим переменным до их объявления; попытка сделать это приведет к ошибке `ReferenceError`.

Давайте разберем, как `let` и `const` ведут себя в TDZ с примерами.

**Пример с `let`**

Когда переменная, объявленная с помощью `let`, вызывается до её инициализации, возникает ошибка:

```javascript
console.log(myLetVar); // ReferenceError: Cannot access 'myLetVar' before initialization
let myLetVar = "Hello";
```

В этом примере, когда мы пытаемся вывести `myLetVar` до его объявления, JavaScript видит, что переменная существует, но не инициализирована, что и приводит к ошибке.

**Пример с `const`**

Переменные, объявленные с помощью `const`, также находятся в TDZ до их инициализации. Если вы попытаетесь получить к ним доступ до этого момента, вы получите похожую ошибку:

```javascript
console.log(myConstVar); // ReferenceError: Cannot access 'myConstVar' before initialization
const myConstVar = "World";
```

Как и в случае с `let`, доступ к `myConstVar` до его объявления вызовет ошибку.

**Пример TDZ в функции**

TDZ также проявляется внутри функций. Посмотрим на следующий пример:

```javascript
function tdzExample() {
  console.log(localVar); // ReferenceError: Cannot access 'localVar' before initialization
  let localVar = "I'm in TDZ";
}

tdzExample();
```

В этом случае, при вызове функции `tdzExample`, попытка доступа к `localVar` до его объявления приводит к ошибке.

**Пример с несколькими уровнями вложенности**

Вы также можете увидеть TDZ при работе с вложенными блоками:

```javascript
{
  console.log(innerVar); // ReferenceError: Cannot access 'innerVar' before initialization
  let innerVar = "I am inside a block";
}
```

Здесь, как и прежде, мы не можем получить доступ к `innerVar` до его объявления, даже если код находится внутри блока.

**Резюме**

- **Temporal Dead Zone** (TDZ) — это область в JavaScript, где переменные, объявленные с `let` и `const`, находятся, но ещё не инициализированы.
- Попытка доступа к переменной в TDZ приводит к ошибке `ReferenceError`.
- TDZ позволяет избежать неясности при использовании переменных, так как доступ к ним до их объявления будет явно блокироваться ошибкой.

Таким образом, понимание TDZ помогает лучше управлять областями видимости и предотвращает потенциальные ошибки при работе с переменными в JavaScript.

#### Вопрос 11. Что такое замыкание (closure)?

Замыкание (closure) — это особый вид функции в JavaScript, который позволяет функции запоминать свое лексическое окружение, даже когда она вызывается вне него. Это означает, что замыкание может «захватывать» переменные своей внешней (родительской) функции и использовать их, даже если родительская функция уже завершила выполнение.

**Как работает замыкание?**

Когда функция объявляется внутри другой функции, сестра наружному контексту замыкания, сохраняется её доступ к переменным из этого контекста. Это позволяет создавать функции с приватными переменными и управлять их состоянием.

**Примеры замыкания**

1. **Простейший пример замыкания**:
```javascript
function outerFunction() {
  const outerVariable = "I'm an outer variable";

  function innerFunction() {
    console.log(outerVariable); // Доступ к внешней переменной
  }

  return innerFunction;
}

const closureFunc = outerFunction();
closureFunc(); // "I'm an outer variable"
```
В этом примере `innerFunction` замыкает переменную `outerVariable`, и вы можете получить к ней доступ, даже после того как `outerFunction` завершила выполнение.

2. **Использование замыкания для создания приватных переменных**:
```javascript
function createCounter() {
  let count = 0; // Приватная переменная

  return {
    increment: function() {
      count++;
      console.log(count);
    },
    decrement: function() {
      count--;
      console.log(count);
    },
    getCount: function() {
      return count;
    }
  };
}

const counter = createCounter();
counter.increment(); // 1
counter.increment(); // 2
console.log(counter.getCount()); // 2
counter.decrement(); // 1
```
В этом примере переменная `count` является приватной и может изменяться только через методы `increment` и `decrement`, что демонстрирует защиту данных.

3. **Замыкание как способ создания функций с параметрами**:
```javascript
function makeMultiplier(multiplier) {
  return function(x) {
    return x * multiplier;
  };
}

const double = makeMultiplier(2);
const triple = makeMultiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15
```
Здесь функция `makeMultiplier` создает замыкания с сохранением значения `multiplier`, и вы можете создать разные функции для умножения на разные значения.

**Резюме**

- **Замыкание** позволяет функции запоминать доступ к переменным из её внешнего (родительского) контекста, даже после завершения этого контекста.
- Это полезно для создания приватных переменных, управления состоянием и динамической генерации функций.

#### Вопрос 12. Как работают `call`, `apply`, `bind`?

Методы `call`, `apply` и `bind` в JavaScript используются для управления контекстом выполнения функции. Все три метода позволяют вам явно задавать значение `this`, указывая, на какой объект будет ссылаться `this` внутри функции. Однако они различаются в способе передачи аргументов. Давайте рассмотрим каждый из них подробнее.

1. **`call()`**

Метод `call()` вызывает функцию с указанным значением `this` и аргументами, переданными по отдельности.

**Синтаксис**:
```javascript
func.call(thisArg, arg1, arg2, ...);
```

**Пример**:
```javascript
function greet(greeting) {
    console.log(greeting + ", " + this.name);
}

const person = { name: "Alice" };
greet.call(person, "Hello"); // "Hello, Alice"
```
В этом примере метод `call()` вызывает функцию `greet`, устанавливая `this` в объект `person`.

2. **`apply()`**

Метод `apply()` аналогичен `call()`, но принимает второй параметр в виде массива (или массивоподобного объекта). Этот массив содержит аргументы, которые передаются в вызываемую функцию.

**Синтаксис**:
```javascript
func.apply(thisArg, [argsArray]);
```

**Пример**:
```javascript
function introduce(greeting, punctuation) {
  console.log(greeting + ", I'm " + this.name + punctuation);
}

const person = { name: "Bob" };
introduce.apply(person, ["Hi", "!"]); // "Hi, I'm Bob!"
```
В этом примере `apply()` вызывает функцию `introduce`, передавая массив аргументов.

3. **`bind()`**

Метод `bind()` создает новую функцию, которая при вызове будет иметь заданное значение `this`, а также фиксированные начальные аргументы. Это полезно, если вы хотите передать функцию с определенным контекстом в другой момент времени.

**Синтаксис**:
```javascript
const boundFunc = func.bind(thisArg, arg1, arg2, ...);
```

**Пример**:
```javascript
function greet() {
  console.log("Hello, " + this.name);
}

const person = { name: "Charlie" };
const greetPerson = greet.bind(person);
greetPerson(); // "Hello, Charlie"
```
В этом примере `bind()` создает новую функцию `greetPerson`, которая всегда будет иметь `this`, указывающее на объект `person`.

**Резюме**

- **`call()`**: вызывает функцию с заданным значением `this` и аргументами, переданными по отдельности.
- **`apply()`**: вызывает функцию с заданным значением `this` и аргументами, переданными в виде массива.
- **`bind()`**: создает новую функцию с фиксированным значением `this` и первичными аргументами, не вызывая функцию.

Эти методы позволяют эффективно управлять контекстом вызова и передавать функции с нужными данными.

#### Вопрос 13. Что такое `this`? Как определяется его значение?

`this` в JavaScript — это специальное ключевое слово, которое ссылается на текущий контекст выполнения функции. Значение `this` определяется тем, как была вызвана функция, и может меняться в зависимости от контекста. Это может вызывать путаницу, поэтому давайте разберём основные правила, определяющие, чему равен `this`.

1. **Глобальный контекст**

В глобальном контексте (вне функций) `this` ссылается на глобальный объект. В браузерах это объект `window`.

**Пример**:
```javascript
console.log(this); // В браузере: Window
```

2. **Контекст функции**

- **Обычная функция**: Если функция вызывается как обычная функция, `this` будет ссылаться на глобальный объект (`window` в браузерах) в нестром режиме. В строгом режиме (`"use strict";`) `this` будет не определён (будет равен `undefined`).

**Пример**:
```javascript
function showThis() {
  console.log(this);
}

showThis(); // В браузере: Window (нестрогий режим)
// В строгом режиме: undefined
```

3. **Контекст метода объекта**

Когда метод вызывается как свойство объекта, `this` ссылается на объект, которому принадлежит метод.

**Пример**:
```javascript
const person = {
  name: "Alice",
  greet: function() {
    console.log("Hello, " + this.name);
  }
};

person.greet(); // "Hello, Alice"
```

4. **Конструктор и `new`**

При вызове функции с помощью оператора `new` `this` ссылается на только что созданный объект.

**Пример**:
```javascript
function Person(name) {
  this.name = name;
}

const alice = new Person("Alice");
console.log(alice.name); // "Alice"
```

5. **`call` и `apply`**

Методы `call()` и `apply()` позволяют явно задавать значение `this`, когда вы вызываете функцию.

**Пример**:
```javascript
function greet() {
  console.log("Hello, " + this.name);
}

const person = { name: "Bob" };
greet.call(person); // "Hello, Bob"
```

6. **`bind`**

Метод `bind()` создаёт новую функцию, которая всегда будет иметь указанное значение `this`.

**Пример**:
```javascript
function greet() {
  console.log("Hello, " + this.name);
}

const person = { name: "Charlie" };
const greetCharlie = greet.bind(person);
greetCharlie(); // "Hello, Charlie"
```

7. **Стрелочные функции**

Стрелочные функции не имеют своего собственного значения `this`; вместо этого они захватывают значение `this` из окружающего контекста в момент их определения.

**Пример**:
```javascript
const person = {
  name: "Dave",
  greet: () => {
    console.log("Hello, " + this.name);
  }
};

person.greet(); // "Hello, undefined", поскольку `this` не указывает на `person`
```

**Резюме**

- Значение `this` в JavaScript зависит от контекста вызова функции.
- В глобальном контексте `this` ссылается на глобальный объект.
- В контексте метода объекта `this` указывает на объект, к которому принадлежит метод.
- При вызове функции с `new` `this` указывает на создаваемый объект.
- `call()`, `apply()` и `bind()` позволяют явно задавать значение `this`.
- Стрелочные функции захватывают значение `this` из окружающего контекста.

#### Вопрос 14. Что такое стрелочные функции? Чем отличаются от обычных?

Стрелочные функции (или arrow functions) — это синтаксический сахар для объявления функций в JavaScript, введённый в ES6 (ECMAScript 2015). Они позволяют более лаконично записывать функции, особенно для коротких и однофункционных выражений.

**Основные особенности стрелочных функций**

1. **Синтаксис**: Стрелочные функции имеют более короткий и удобный синтаксис по сравнению с обычными функциями.

**Пример**:
```javascript
// Обычная функция
function add(a, b) {
   return a + b;
}

// Стрелочная функция
const addArrow = (a, b) => a + b;
```

2. **Отсутствие собственного `this`**: Одной из самых больших особенностей стрелочных функций является то, что они не имеют своего собственного значения `this`. Вместо этого `this` наследуется из внешнего (родительского) контекста, в котором была объявлена стрелочная функция. Это делает их особенно полезными при работе с методами объектов и обработчиками событий.

**Пример**:
```javascript
const person = {
  name: "Alice",
  greet: function() {
    setTimeout(() => {
      console.log("Hello, " + this.name); // `this` указывает на `person`
      }, 1000);
   }
};

person.greet(); // "Hello, Alice" через 1 секунду
```

3. **Невозможность использования в качестве конструктора**: Стрелочные функции не могут быть вызваны с использованием оператора `new`. Это означает, что их нельзя использовать для создания объектов.

**Пример**:
```javascript
const Person = (name) => {
  this.name = name; // Не будет работать так, как ожидается
};

const john = new Person("John"); // TypeError: Person is not a constructor
```

4. **Отсутствие своего `arguments`**: Стрелочные функции не имеют собственных параметров `arguments`. Однако вы можете использовать оператор расширения `...` для этого.

**Пример**:
```javascript
const multiply = (...args) => {
  return args.reduce((acc, curr) => acc * curr, 1);
};

console.log(multiply(2, 3, 4)); // 24
```

5. **Краткий синтаксис для однофункционных выражений**: Если тело стрелочной функции состоит из единственного выражения, вы можете опустить фигурные скобки и оператор `return`.

**Пример**:
```javascript
const square = x => x * x;
console.log(square(4)); // 16
```

**Резюме**

- **Синтаксис**: Простое и краткое объявление функций.
- **Отсутствие собственного `this`**: `this` захватывается из внешнего контекста.
- **Невозможность использования в качестве конструктора**.
- **Отсутствие собственного `arguments`**: Можно использовать оператор расширения.
- **Краткий синтаксис**: Можно опустить фигурные скобки и `return` для однострочных выражений.

Стрелочные функции часто используются, чтобы сделать код более читабельным и избежать проблем с контекстом вызова `this`.

#### Вопрос 15. Что такое IIFE (Immediately Invoked Function Expression)?

IIFE (Immediately Invoked Function Expression) — это функция, которая определяется и вызывается немедленно после её создания. Это позволяет создавать новый контекст выполнения, изолируя переменные и функции внутри, что помогает избежать конфликтов с другими переменными в глобальной области видимости.

**Синтаксис IIFE**

IIFE обычно записывается в виде анонимной функции, обёрнутой в круглые скобки, за которой следует пара круглых скобок для немедленного вызова. Вот общий синтаксис:

```javascript
(function() {
  // Код выполняется немедленно
})();
```

Если нужна функция с аргументами, синтаксис выглядит следующим образом:

```javascript
(function(arg1, arg2) {
  // Код выполняется немедленно
})(value1, value2);
```

**Примеры IIFE**

1. **Простой пример**:

```javascript
(function() {
  console.log("Hello, World!");
})();
```
В этом примере анонимная функция выполняется сразу же, и выводит "Hello, World!" в консоль.

2. **Создание изолированной области видимости**:

```javascript
var globalVar = "I'm global";

(function() {
  var localVar = "I'm local";
  console.log(localVar); // "I'm local"
})();

console.log(globalVar); // "I'm global"
// console.log(localVar); // ReferenceError: localVar is not defined
```
Здесь переменная `localVar` находится в локальной области видимости и недоступна из глобального контекста. Таким образом, IIFE позволяет защитить переменные от загрязнения глобальной области видимости.

3. **Приём для создания модулей**:

IIFE часто используется для создания модулей и управления видимостью переменных.

```javascript
var counter = (function() {
  var count = 0;

  return {
    increment: function() {
      count++;
      console.log(count);
    },
    decrement: function() {
      count--;
      console.log(count);
    },
    getCount: function() {
      return count;
    }
  };
})();

counter.increment(); // 1
counter.increment(); // 2
console.log(counter.getCount()); // 2
counter.decrement(); // 1
```
В этом примере IIFE создаёт модуль `counter`, который инкапсулирует переменную `count`, обеспечивая доступ к методам для её изменения, но не позволяя пользователю напрямую получать или изменять `count`.

**Резюме**

- **IIFE** позволяет немедленно вызвать функцию после её объявления.
- Он создаёт изолированную область видимости, что помогает избежать загрязнения глобального пространства имён.
- Часто используется для создания модулей и управления видимостью переменных при разработке более сложных приложений.

---

### Часть 2. Функции и методы

#### Вопрос 16. Что такое callback-функция? 

Callback-функция — это функция, которая передается в другую функцию в качестве аргумента и вызывается после завершения определенной операции или события. Это один из основных способов работы с асинхронным кодом в JavaScript, позволяющий выполнять код после завершения длительных операций, таких как запросы к серверу, таймеры или обработка событий.

**Основные особенности callback-функций**:

1. **Асинхронность**: Callback-функции часто используются для обработки результатов асинхронных операций. Они обеспечивают возможность кода «ждать» завершения этих операций, прежде чем выполнять дальнейшие действия.

2. **Гибкость**: Callbacks позволяют передавать поведение, которое можно определить в месте вызова функции, что делает код более модульным и переиспользуемым.

**Примеры callback-функций**

1. **Простой пример**:

```javascript
function greet(name, callback) {
    console.log("Hello, " + name);
    if (callback) {
        callback();
    }
}

function goodBye() {
    console.log("Goodbye!");
}

greet("Alice", goodBye);
// Вывод:
 // Hello, Alice
 // Goodbye!
```
В этом примере функция `greet` принимает имя и callback-функцию `goodBye`, которая вызывается после приветствия.

2. **Асинхронные операции**:

```javascript
function fetchData(callback) {
    setTimeout(() => {
        const data = "Data from server";
        callback(data);
    }, 1000);
}

fetchData(function(result) {
    console.log(result); // "Data from server" через 1 секунду
});
```
В этом примере функция `fetchData` использует `setTimeout`, чтобы симулировать асинхронный запрос к серверу. После завершения «запроса» вызывается переданная callback-функция, которая обрабатывает полученные данные.

3. **Использование стрелочных функций как callbacks**:

```javascript
const numbers = [1, 2, 3, 4, 5];

const squaredNumbers = numbers.map((num) => num * num);
console.log(squaredNumbers); // [1, 4, 9, 16, 25]
```
В этом примере метод `map` массива принимает callback-функцию для преобразования данных в новый массив. Здесь в качестве callback используется стрелочная функция, которая возвращает квадрат числа.

**Резюме**

- **Callback-функция** — это функция, переданная в другую функцию как аргумент и вызываемая по завершении определенной операции.
- Используются для обработки асинхронных операций, такие как запросы к серверу или обработка событий.
- Позволяют создавать более гибкий и переиспользуемый код.


#### Вопрос 17. Что такое рекурсия?

Рекурсия — это метод программирования, при котором функция вызывает саму себя для решения подзадачи, пока не будет достигнуто базовое условие, при котором выполнение функции прекращается. Рекурсия часто используется для решения задач, которые могут быть разбиты на более мелкие подзадачи аналогичного типа.

**Принципы рекурсии**

1. **Базовое условие**: Это условие, которое завершает рекурсию. Оно необходимо, чтобы избежать бесконечных вызовов функции.

2. **Рекурсивный случай**: Это то, где функция вызывает саму себя с изменёнными аргументами, приближаясь к базовому условию.

**Примеры рекурсии**

1. **Факториал числа**:

Факториал (обозначается как `n!`) — это произведение всех положительных целых чисел от 1 до `n`. 

```javascript
function factorial(n) {
    if (n === 0 || n === 1) {
        return 1; // Базовое условие
    }
    return n * factorial(n - 1); // Рекурсивный случай
}

console.log(factorial(5)); // 120
```

В этом примере функция `factorial` вызывает саму себя, передавая в качестве аргумента `n - 1`, пока не дойдёт до базового условия (`n` равного 0 или 1).

2. **Числа Фибоначчи**:

Числа Фибоначчи — это последовательность, где каждое число является суммой двух предыдущих чисел. Обычно определение начинается с `0` и `1`.

```javascript
function fibonacci(n) {
    if (n === 0) {
        return 0; // Базовое условие
    }
    if (n === 1) {
        return 1; // Базовое условие
    }
    return fibonacci(n - 1) + fibonacci(n - 2); // Рекурсивный случай
}

console.log(fibonacci(6)); // 8 (последовательность: 0, 1, 1, 2, 3, 5, 8)
```

Здесь функция `fibonacci` вызывает саму себя дважды для вычисления суммы двух предыдущих чисел в последовательности, пока не достигнет базовых условий.

3. **Обход дерева**:

Рекурсия часто используется для обхода структур данных, таких как деревья. Например, можно использовать рекурсию для печати значений узлов в дереве.

```javascript
const tree = {
    value: 1,
    left: {
        value: 2,
        left: null,
        right: null
    },
    right: {
        value: 3,
        left: null,
        right: null
    }
};

function traverse(node) {
    if (node) {
        console.log(node.value); // Вывод значения текущего узла
        traverse(node.left); // Рекурсивный вызов для левого поддерева
        traverse(node.right); // Рекурсивный вызов для правого поддерева
    }
}

traverse(tree); // 1 2 3
```

**Резюме**

- **Рекурсия** — это метод программирования, при котором функция вызывает саму себя.
- Она состоит из базового условия, которое завершает рекурсию, и рекурсивного случая, который приближает выполнение к базовому условию.
- Рекурсия часто используется для вычисления факториала, чисел Фибоначчи и обхода деревьев.

Рекурсия может быть мощным инструментом, но важно следить за тем, чтобы избежать бесконечной рекурсии, которая может привести к переполнению стека.


#### Вопрос 18. Как работают методы массивов: `map`, `filter`, `reduce`?

Методы массивов `map`, `filter` и `reduce` в JavaScript — это мощные инструменты для работы с массивами, позволяющие эффективно обрабатывать и трансформировать данные. Давайте рассмотрим каждый из этих методов подробнее.

1. **`map()`**

Метод `map()` создаёт новый массив, состоящий из результатов вызова функции для каждого элемента исходного массива. Он не изменяет исходный массив.

**Синтаксис**:
```javascript
const newArray = array.map((element, index, array) => {
    // Возвращаемое значение для нового массива
});
```

**Пример**:
```javascript
const numbers = [1, 2, 3, 4];
const squaredNumbers = numbers.map(num => num * num);
console.log(squaredNumbers); // [1, 4, 9, 16]
```

В этом примере метод `map()` применяет функцию возведения в квадрат ко всем элементам массива `numbers` и возвращает новый массив `squaredNumbers`.

2. **`filter()`**

Метод `filter()` создаёт новый массив, содержащий все элементы исходного массива, которые удовлетворяют условию, заданному в предоставленной функции. Он также не изменяет исходный массив.

**Синтаксис**:
```javascript
const newArray = array.filter((element, index, array) => {
    // Условие для фильтрации
});
```

**Пример**:
```javascript
const numbers = [1, 2, 3, 4, 5];
const evenNumbers = numbers.filter(num => num % 2 === 0);
console.log(evenNumbers); // [2, 4]
```

В этом примере метод `filter()` возвращает новый массив `evenNumbers`, в который входят только чётные числа из массива `numbers`.

3. **`reduce()`**

Метод `reduce()` применяется для практически любого типа редукции массива к единственному значению. Он обрабатывает каждый элемент массива и аккумулирует результат в одно значение.

**Синтаксис**:
```javascript
const result = array.reduce((accumulator, currentValue, index, array) => {
    // Логика аккумуляции
}, initialValue);
```

- `accumulator`: аккумулятор, который накапливает текущий результат.
- `currentValue`: текущий элемент, который обрабатывается.
- `initialValue`: значение, с которого начинается аккумуляция.

**Пример**:
```javascript
const numbers = [1, 2, 3, 4];
const sum = numbers.reduce((acc, num) => acc + num, 0);
console.log(sum); // 10
```

В этом примере метод `reduce()` суммирует все элементы массива `numbers`, начиная с 0. `acc` — это аккумулятор, который накапливает результат.

**Объединение методов**

Эти методы могут также использоваться совместно для более сложных операций. Например, можно сначала отфильтровать массив, а затем применить `map()`.

**Пример**:

```javascript
const numbers = [1, 2, 3, 4, 5, 6];

// Сначала фильтруем четные числа, затем возводим их в квадрат
const result = numbers
    .filter(num => num % 2 === 0) // [2, 4, 6]
    .map(num => num * num);      // [4, 16, 36]

console.log(result); // [4, 16, 36]
```

**Резюме**

- **`map()`**: Создаёт новый массив, применяя функцию к каждому элементу исходного массива.
- **`filter()`**: Создаёт новый массив, состоящий из элементов, удовлетворяющих условию, заданному в функции.
- **`reduce()`**: Позволяет редуцировать массив к одному значению, аккумулируя его по заданной логике.

Эти методы делают работу с массивами более удобной и читаемой.


#### Вопрос 19. Как проверить, что объект является массивом?

В JavaScript существует несколько способов проверить, что объект является массивом. Вот наиболее распространённые методы:

**1. Использование `Array.isArray()`**

Этот метод является наиболее надежным и рекомендованным способом проверки. Он возвращает `true`, если переданный аргумент является массивом, и `false` в противном случае.

**Пример**:
```javascript
const arr = [1, 2, 3];
const obj = { name: "Alice" };

console.log(Array.isArray(arr)); // true
console.log(Array.isArray(obj)); // false
```

2. **Использование `instanceof`**

Оператор `instanceof` проверяет, принадлежит ли объект к определённому классу. В данном случае можно проверить, является ли объект экземпляром класса `Array`.

**Пример**:
```javascript
const arr = [1, 2, 3];
const obj = { name: "Alice" };

console.log(arr instanceof Array); // true
console.log(obj instanceof Array); // false
```

3. **Использование `Object.prototype.toString()`**

Этот метод позволяет получить строку, описывающую тип объекта. Для массивов возвращается "[object Array]".

**Пример**:
```javascript
const arr = [1, 2, 3];
const obj = { name: "Alice" };

console.log(Object.prototype.toString.call(arr) === "[object Array]"); // true
console.log(Object.prototype.toString.call(obj) === "[object Array]"); // false
```

4. **Сравнение с `Array.prototype`**

Можно также проверить, к какому прототипу относится объект, сравнив его с `Array.prototype`. Однако этот метод менее распространён и может привести к некорректным результатам, если объект был создан с использованием другого глобального контекста (например, если код выполняется в разных ифреймах).

**Пример**:
```javascript
const arr = [1, 2, 3];
const obj = { name: "Alice" };

console.log(arr.constructor === Array); // true
console.log(obj.constructor === Array); // false
```

**Резюме**

Наиболее надёжным и распространённым способом проверки, является ли объект массивом, является использование `Array.isArray()`. Этот метод прост в использовании и не требует дополнительных проверок.


#### Вопрос 20. Как сделать глубокую копию объекта?

Глубокое копирование объекта — это процесс создания новой копии объекта, включая все вложенные объекты и массивы, таким образом, чтобы изменения в новой копии не влияли на оригинальный объект и наоборот. В JavaScript нет встроенного метода для глубокого копирования объектов, но можно использовать несколько подходов для достижения этой цели. 

1. **Использование `JSON.stringify()` и `JSON.parse()`**

Один из самых простых способов создания глубокой копии объекта — это использовать методы `JSON.stringify()` и `JSON.parse()`. Однако этот метод имеет свои ограничения: он не копирует функции, символы, объекты `Date`, а также не подходит для объектов с циклическими ссылками.

**Пример**:
```javascript
const original = {
    name: "Alice",
    age: 30,
    hobbies: ["reading", "traveling"],
    address: {
        city: "Wonderland",
        zip: "12345"
    }
};

const copy = JSON.parse(JSON.stringify(original));

copy.name = "Bob"; // Изменяем имя в копии
copy.hobbies.push("cooking"); // Добавляем новое хобби
copy.address.city = "New Wonderland"; // Изменяем город в копии

console.log(original.name); // Alice
console.log(original.hobbies); // ["reading", "traveling"]
console.log(original.address.city); // Wonderland
```

2. **Использование рекурсивной функции**

Другой способ создать глубокую копию — написать собственную рекурсивную функцию, которая будет обрабатывать объекты и массивы.

**Пример**:
```javascript
function deepClone(obj) {
    // Проверяем, является ли объект массивом
    if (Array.isArray(obj)) {
        return obj.map(item => deepClone(item));
    }

    // Проверяем, является ли объект обычным объектом
    if (obj && typeof obj === 'object') {
        const clonedObj = {};
        for (let key in obj) {
            if (obj.hasOwnProperty(key)) {
                clonedObj[key] = deepClone(obj[key]);
            }
        }
        return clonedObj;
    }

    // Если это не объект или массив, просто возвращаем его
    return obj;
}

const original = {
    name: "Alice",
    age: 30,
    hobbies: ["reading", "traveling"],
    address: {
        city: "Wonderland",
        zip: "12345"
    }
};

const copy = deepClone(original);
copy.name = "Bob";
copy.hobbies.push("cooking");
copy.address.city = "New Wonderland";

console.log(original.name); // Alice
console.log(original.hobbies); // ["reading", "traveling"]
console.log(original.address.city); // Wonderland
```

3. **Использование библиотеки**

Можно использовать сторонние библиотеки, такие как Lodash, которая имеет встроенный метод для глубокого копирования объектов.

**Пример с использованием Lodash**:
```javascript
// Убедитесь, что Lodash установлен
// npm install lodash
const _ = require('lodash');

const original = {
    name: "Alice",
    age: 30,
    hobbies: ["reading", "traveling"],
    address: {
        city: "Wonderland",
        zip: "12345"
    }
};

const copy = _.cloneDeep(original);

copy.name = "Bob";
copy.hobbies.push("cooking");
copy.address.city = "New Wonderland";

console.log(original.name); // Alice
console.log(original.hobbies); // ["reading", "traveling"]
console.log(original.address.city); // Wonderland
```

**Резюме**

- Для простого создания глубокой копии объекта можно использовать `JSON.stringify()` и `JSON.parse()` (но помните об ограничениях этого метода).
- Можно написать рекурсивную функцию для глубокого копирования, что даст больше контроля над процессом.
- Для более сложных случаев можно использовать сторонние библиотеки, такие как Lodash, которые имеют встроенные методы для глубокого копирования объектов.


#### Вопрос 21. Как объединить два объекта?  

В JavaScript существует несколько способов объединения двух объектов, и каждый из них может подойти для разных сценариев. Вот самые распространённые методы:

1. **Использование `Object.assign()`**

Метод `Object.assign()` используется для копирования значений всех перечисляемых свойств из одного или нескольких объектов-источников в целевой объект. Этот метод возвращает целевой объект.

**Пример**:
```javascript
const obj1 = { a: 1, b: 2 };
const obj2 = { b: 3, c: 4 };

const merged = Object.assign({}, obj1, obj2);

console.log(merged); // { a: 1, b: 3, c: 4 }
```
В этом примере свойства из `obj1` и `obj2` объединяются в новый объект `merged`. Обратите внимание, что значение свойства `b` из `obj2` перезаписывает значение свойства `b` из `obj1`.

2. **Использование оператора расширения (`...`)**

С оператором расширения (spread operator) можно легко объединить объекты, создавая новый объект с массивом свойств.

**Пример**:
```javascript
const obj1 = { a: 1, b: 2 };
const obj2 = { b: 3, c: 4 };

const merged = { ...obj1, ...obj2 };

console.log(merged); // { a: 1, b: 3, c: 4 }
```
Это аналогично методу `Object.assign()`, но он более лаконичен и читаем.

3. **Использование `Object.entries()` и `reduce()`**

Можно объединять объекты с помощью методов `Object.entries()` и `reduce()`, что позволяет более гибко обрабатывать свойства объектов.

**Пример**:
```javascript
const obj1 = { a: 1, b: 2 };
const obj2 = { b: 3, c: 4 };

const merged = [obj1, obj2].reduce((acc, obj) => {
    return { ...acc, ...obj };
}, {});

console.log(merged); // { a: 1, b: 3, c: 4 }
```
В этом примере массив с объектами проходит через `reduce()`, и свойства объединяются в один объект.

4. **Использование библиотеки `lodash`**

Если вы используете сторонние библиотеки, такие как Lodash, можно использовать функцию `_.merge()`, которая объединит объекты, сохраняя вложенные структуры.

**Пример**:
```javascript
// Убедитесь, что Lodash установлен
// npm install lodash
const _ = require('lodash');

const obj1 = { a: 1, b: { c: 2 } };
const obj2 = { b: { d: 3 }, e: 4 };

const merged = _.merge({}, obj1, obj2);

console.log(merged); // { a: 1, b: { c: 2, d: 3 }, e: 4 }
```
Этот метод будет объединять свойства, включая вложенные структуры.

**Резюме**

- **`Object.assign()`** и **оператор расширения (`...`)** позволяют сливать объекты и создают новый объект.
- **`reduce()`** и **`Object.entries()`** дают возможность гибко объединять объекты.
- Библиотеки, такие как Lodash, предлагают более сложные методы для глубокого объединения объектов.


#### Вопрос 22. Как проверить, что свойство есть в объекте?

В JavaScript есть несколько способов проверить наличие свойства в объекте. Вот наиболее распространённые методы:

1. **Оператор `in`**

Оператор `in` проверяет, существует ли указанное свойство в объекте или в его прототипе. Если свойство найдено, оператор возвращает `true`.

**Пример**:
```javascript
const obj = {
    name: "Alice",
    age: 30
};

console.log("name" in obj); // true
console.log("address" in obj); // false
```

2. **Метод `hasOwnProperty()`**

Метод `hasOwnProperty()` проверяет, есть ли указанное свойство непосредственно в само́м объекте (без учёта свойств из прототипа). Этот метод возвращает `true`, если свойство найдено.

**Пример**:
```javascript
const obj = {
    name: "Alice",
    age: 30
};

console.log(obj.hasOwnProperty("name")); // true
console.log(obj.hasOwnProperty("address")); // false
```

3. **Проверка на `undefined`**

Можно проверить, существует ли свойство, сравнив его значение с `undefined`. Однако этот подход не учитывает, если свойство действительно есть, но имеет значение `undefined`.

**Пример**:
```javascript
const obj = {
    name: "Alice",
    age: undefined
};

console.log(obj.age !== undefined); // false (плохо, если `age` действительно должно быть `undefined`)
console.log(obj.address !== undefined); // false
```

4. **Использование `Object.keys()`**

Можно использовать метод `Object.keys()` для получения массива всех собственных перечисляемых свойств объекта и затем проверить, содержится ли нужное свойство в этом массиве.

**Пример**:
```javascript
const obj = {
    name: "Alice",
    age: 30
};

const keys = Object.keys(obj);
console.log(keys.includes("name")); // true
console.log(keys.includes("address")); // false
```

**Резюме**

- **Оператор `in`** позволяет проверять наличие свойств как в самом объекте, так и в его прототипе.
- **`hasOwnProperty()`** проверяет только собственные свойства объекта.
- Проверка на `undefined` требует осторожности, так как значения свойства могут быть `undefined`.
- **`Object.keys()`** можно использовать для получения всех собственных свойств и проверки их наличия.


#### Вопрос 23. Что такое деструктуризация?

Деструктуризация в JavaScript — это синтаксический сахар, который позволяет удобно извлекать значения из массивов и объектов и присваивать их переменным. Этот подход позволяет улучшить читаемость кода и сократить количество строк при работе с данными.

1. **Деструктуризация объектов**

При деструктуризации объектов вы можете извлекать значения свойств и присваивать их переменным с использованием синтаксиса фигурных скобок `{}`.

**Пример**:
```javascript
const person = {
    name: "Alice",
    age: 30,
    city: "Wonderland"
};

// Деструктурируем объект
const { name, age } = person;

console.log(name); // Alice
console.log(age); // 30
```

В этом примере мы извлекаем свойства `name` и `age` из объекта `person` и присваиваем их одноимённым переменным.

2. **Переименование переменных**

Вы также можете переименовывать переменные при деструктуризации, если имена свойств и переменных не совпадают.

**Пример**:
```javascript
const person = {
    name: "Alice",
    age: 30
};

// Деструктурируем и переименовываем
const { name: personName, age: personAge } = person;

console.log(personName); // Alice
console.log(personAge); // 30
```

3. **Деструктуризация массивов**

Деструктуризация массивов выполняется с помощью квадратных скобок `[]`, и значения извлекаются в том порядке, в котором они находятся в массиве.

**Пример**:
```javascript
const colors = ["red", "green", "blue"];

// Деструктурируем массив
const [firstColor, secondColor] = colors;

console.log(firstColor); // red
console.log(secondColor); // green
```

4. **Значения по умолчанию**

При деструктуризации вы можете задавать значения по умолчанию для переменных на случай, если соответствующее свойство или элемент отсутствует.

**Пример**:
```javascript
const person = {
    name: "Alice"
};

// Деструктурируем с значением по умолчанию
const { name, age = 25 } = person;

console.log(name); // Alice
console.log(age); // 25 (значение по умолчанию)
```

5. **Деструктуризация вложенных объектов**

Деструктуризация может использоваться и для вложенных объектов. Просто указывайте свойства, которые хотите извлечь, в необходимом порядке.

**Пример**:
```javascript
const person = {
    name: "Alice",
    address: {
        city: "Wonderland",
        zip: "12345"
    }
};

// Деструктурируем вложенный объект
const { name, address: { city } } = person;

console.log(name); // Alice
console.log(city); // Wonderland
```

**Резюме**

Деструктуризация — это удобный метод извлечения значений из объектов и массивов, который позволяет писать более понятный и компактный код. Вы можете извлекать значения, переименовывать переменные, задавать значения по умолчанию и работать с вложенными структурами данных.


#### Вопрос 24. Что такое rest и spread операторы?

Rest и spread операторы — это два связанных синтаксиса в JavaScript, которые используют троеточие (`...`) для работы с массивами и объектами. Давайте рассмотрим их подробнее.

1. **Spread оператор (`...`)**

**Spread оператор** позволяет развернуть (или "распространить") элементы массива или свойства объекта в другом массиве или объекте. Он часто используется для объединения массивов, копирования объектов и массивов, а также для передачи аргументов в функции.

**Примеры использования Spread оператора**:

**Объединение массивов**:
```javascript
const array1 = [1, 2, 3];
const array2 = [4, 5, 6];

const combined = [...array1, ...array2];

console.log(combined); // [1, 2, 3, 4, 5, 6]
```

**Копирование массива**:
```javascript
const originalArray = [1, 2, 3];
const copiedArray = [...originalArray];

console.log(copiedArray); // [1, 2, 3]
```

**Копирование и объединение объектов**:
```javascript
const obj1 = { a: 1, b: 2 };
const obj2 = { b: 3, c: 4 };

const merged = { ...obj1, ...obj2 };

console.log(merged); // { a: 1, b: 3, c: 4 }
```

2. **Rest оператор (`...`)**

**Rest оператор** позволяет собрать все оставшиеся аргументы функции или свойства объекта в массив. Это полезно, когда нужно передать переменное количество аргументов в функцию.

**Примеры использования Rest оператора**:

**Передача переменного количества аргументов**:
```javascript
function sum(...numbers) {
    return numbers.reduce((acc, num) => acc + num, 0);
}

console.log(sum(1, 2, 3)); // 6
console.log(sum(10, 20, 30, 40)); // 100
```

**Сбор свойств объекта**:
```javascript
const person = {
    name: "Alice",
    age: 30,
    city: "Wonderland"
};

// Извлечение свойств с использованием rest оператора
const { name, ...otherProperties } = person;

console.log(name); // Alice
console.log(otherProperties); // { age: 30, city: "Wonderland" }
```

**Резюме**

- **Spread оператор (`...`)** используется для развертывания элементов массива или свойств объекта. Он полезен для объединения массивов и объектов, а также для копирования.
- **Rest оператор (`...`)** позволяет собирать оставшиеся аргументы в функцию или свойства объекта в массив. Это полезно для работы с переменным числом аргументов и извлечения остальной части свойств объекта.


#### Вопрос 25. Как работают `Object.keys()`, `Object.values()`, `Object.entries()`?

`Object.keys()`, `Object.values()` и `Object.entries()` — это три встроенных метода в JavaScript, которые позволяют работать с объектами, извлекая из них ключи, значения и пары ключ-значение соответственно. Давайте рассмотрим, как каждый из этих методов работает с примерами.

1. **`Object.keys()`**

Метод `Object.keys(obj)` возвращает массив строк, содержащий имена (ключи) всех собственных перечисляемых свойств объекта `obj`.

**Пример**:
```javascript
const person = {
    name: "Alice",
    age: 30,
    city: "Wonderland"
};

const keys = Object.keys(person);
console.log(keys); // ["name", "age", "city"]
```

2. **`Object.values()`**

Метод `Object.values(obj)` возвращает массив, содержащий значения всех собственных перечисляемых свойств объекта `obj`.

**Пример**:
```javascript
const person = {
    name: "Alice",
    age: 30,
    city: "Wonderland"
};

const values = Object.values(person);
console.log(values); // ["Alice", 30, "Wonderland"]
```

3. **`Object.entries()`**

Метод `Object.entries(obj)` возвращает массив массивов, где каждый внутренний массив содержит пару `[ключ, значение]`, соответствующую каждому собственному перечисляемому свойству объекта `obj`.

**Пример**:
```javascript
const person = {
    name: "Alice",
    age: 30,
    city: "Wonderland"
};

const entries = Object.entries(person);
console.log(entries); // [["name", "Alice"], ["age", 30], ["city", "Wonderland"]]
```

**Использование**

Эти методы полезны для итерации по объектам и получения информации о их структуре.

**Пример с итерацией**:

Вот пример, в котором мы используем все три метода для итерации по объекту и вывода его ключей, значений и пар ключ-значение:

```javascript
const person = {
    name: "Alice",
    age: 30,
    city: "Wonderland"
};

// Итерация с использованием Object.keys()
Object.keys(person).forEach(key => {
    console.log(`${key}: ${person[key]}`);
});

// Итерация с использованием Object.values()
Object.values(person).forEach(value => {
    console.log(value);
});

// Итерация с использованием Object.entries()
Object.entries(person).forEach(([key, value]) => {
    console.log(`${key} = ${value}`);
});
```

**Резюме**

- `Object.keys(obj)` возвращает массив ключей объекта.
- `Object.values(obj)` возвращает массив значений объекта.
- `Object.entries(obj)` возвращает массив пар ключ-значение объекта.

Эти методы позволяют удобно работать с объектами и могут значительно упростить код при их использовании. 

---

### Часть 3. Асинхронность и работа с сервером

#### Вопрос 26. Что такое Event Loop?

Event Loop (цикл событий) в JavaScript — это механизм, который позволяет выполнять асинхронный код, управляя задачами, которые должны быть выполнены после завершения текущего выполнения стека (call stack). Он обеспечивает неблокирующее выполнение кода, позволяя JavaScript эффективно обрабатывать события и выполнять асинхронные операции. Давайте рассмотрим его работу более подробно.

**Как работает Event Loop**

1. **Call Stack (стек вызовов)**: Это стек, который хранит выполняемые функции. Когда JavaScript выполняет код, он помещает функции в стек, а по завершении они удаляются из него.

2. **Web APIs (веб API)**: Асинхронные функции, такие как таймеры (setTimeout, setInterval), HTTP запросы и обработчики событий, обрабатываются браузером в веб API.

3. **Task Queue (очередь задач)**: Когда асинхронная функция завершается, её коллбек помещается в очередь задач, ожидая, когда стек вызовов станет пустым.

4. **Event Loop**: Это компонент, который следит за стеком вызовов и очередью задач. Когда стек пуст, он берет первую задачу из очереди и помещает её в стек для выполнения.

**Пример работы Event Loop**

Рассмотрим простой пример для иллюстрации работы Event Loop:

```javascript
console.log("Start");

setTimeout(() => {
    console.log("Callback 1");
}, 0);

setTimeout(() => {
    console.log("Callback 2");
}, 100);

console.log("End");
```

**Ожидаемый вывод**:

```
Start
End
Callback 1
Callback 2
```

**Как это происходит**:

1. `"Start"` выводится в стек, выполняется, а затем удаляется.
2. Вызывается `setTimeout` с коллбеком, который добавляется в веб API. Он не выполняется немедленно, а будет выполнен по истечении времени.
3. Далее `setTimeout` с временем 100 мс также помещается в веб API.
4. `"End"` выводится, выполняется и удаляется из стека.
5. Теперь стек вызовов пуст, и Event Loop проверяет очередь задач. Находит `Callback 1` из первого `setTimeout` и помещает его в стек, чтобы выполнить. Выводится `"Callback 1"`.
6. Стек снова пуст, и Event Loop обрабатывает следующий коллбек из очереди задач (`Callback 2`). Выводится `"Callback 2"`.

**Пример с использованием Promise**

Promises также работают с Event Loop и позволяют обрабатывать асинхронные действия.

```javascript
console.log("Start");

setTimeout(() => {
    console.log("Timeout");
}, 0);

Promise.resolve()
    .then(() => {
        console.log("Promise");
    });

console.log("End");
```

**Ожидаемый вывод**:

```
Start
End
Promise
Timeout
```

**Как это происходит**:

1. `"Start"` выводится и удаляется из стека.
2. `setTimeout` помещает коллбек в очередь задач веб API.
3. Promise вызывается, и его `.then()` помещается в очередь микрозадач.
4. `"End"` выводится и удаляется.
5. Стек пуст, и Event Loop сначала обрабатывает микрозадачи. Выполняется `Promise`, который выводит `"Promise"`.
6. Затем обрабатывается очередь задач, и выводится `"Timeout"`.

**Резюме**

Event Loop — это механизм, позволяющий JavaScript выполнять асинхронный код, управляя выполнением коллбеков из очереди задач и микрозадач, когда вызовы в стеке завершены. Он обеспечивает неблокирующую природу JavaScript, позволяя ему работать с событиями и асинхронными операциями эффективно.


#### Вопрос 27. Объясни разницу между `setTimeout`, `setInterval`, `requestAnimationFrame`.

`setTimeout`, `setInterval` и `requestAnimationFrame` — это функции, которые позволяют выполнять асинхронный код в JavaScript, но они предназначены для различных сценариев и работают по-разному. Давайте рассмотрим каждый из этих методов и их отличия.

1. **`setTimeout`**

`setTimeout` используется для выполнения функции один раз через заданный интервал времени (в миллисекундах).

**Пример**:
```javascript
console.log("Start");

setTimeout(() => {
    console.log("Executed after 2 seconds");
}, 2000);

console.log("End");
```

**Ожидаемый вывод**:
```
Start
End
Executed after 2 seconds
```

2. **`setInterval`**

`setInterval` используется для выполнения функции многократно через заданные интервалы времени (в миллисекундах). Это полезно для выполнения действия с регулярной периодичностью.

**Пример**:
```javascript
let count = 0;
const intervalId = setInterval(() => {
    count++;
    console.log(`Executed ${count} times`);
    
    if (count === 5) {
        clearInterval(intervalId); // Остановка интервала
        console.log("Interval cleared");
    }
}, 1000);
```

**Ожидаемый вывод**:
```
Executed 1 times
Executed 2 times
Executed 3 times
Executed 4 times
Executed 5 times
Interval cleared
```

3. **`requestAnimationFrame`**

`requestAnimationFrame` используется для обновления графики в браузере. Он синхронизирует выполнение вашего кода с частотой обновления экрана, что делает его идеальным для анимаций. Функция будет вызвана перед следующим перерисовыванием экрана, что позволяет избегать пропусков кадров и улучшает производительность.

**Пример**:
```javascript
let pos = 0;

function animate() {
    pos += 1; // Изменение позиции
    console.log(`Position: ${pos}`);
    
    if (pos < 100) {
        requestAnimationFrame(animate); // Рекурсивный вызов
    }
}

requestAnimationFrame(animate);
```

**Ожидаемый вывод (по мере выполнения)**:
```
Position: 1
Position: 2
Position: 3
...
Position: 99
Position: 100
```

**Краткое сравнение**:

| Метод                   | Описание                                                      | Как использовать                           |
|-------------------------|--------------------------------------------------------------|-------------------------------------------|
| `setTimeout`            | Выполняет функцию один раз через заданный интервал          | `setTimeout(fn, delay)`                  |
| `setInterval`           | Выполняет функцию многократно через заданные интервалы       | `setInterval(fn, interval)`               |
| `requestAnimationFrame` | Начинает цикл анимации, вызывая функцию перед следующей перерисовкой экрана | `requestAnimationFrame(fn)`               |

**Выбор метода**

- Используйте **`setTimeout`**, когда нужно выполнить функцию один раз через некоторый интервал времени.
- Используйте **`setInterval`**, если нужно регулярно выполнять функцию с определённым таймаутом.
- Используйте **`requestAnimationFrame`** для задач, связанных с анимацией, поскольку он синхронизирует выполнение с графическим контекстом браузера, обеспечивая более плавные анимации и эффективность.


#### Вопрос 28. Что такое Promise? Как создать и обработать?

Promise в JavaScript — это объект, который представляет завершение (или отказ) асинхронной операции и позволяет обрабатывать результаты таких операций. Промисы помогают упростить работу с асинхронным кодом, устраняя «callback hell» (ад обратных вызовов) и позволяя писать более чистый и читаемый код.

**Основные состояния Promise**

1. **Pending (ожидание)**: начальное состояние, промис еще не завершён.
2. **Fulfilled (выполнен)**: операция завершена успешно.
3. **Rejected (отклонён)**: операция завершена с ошибкой.

**Создание Promise**

Для создания промиса используется конструктор `Promise`, который принимает одну функцию с двумя параметрами: `resolve` и `reject`. Эти функции используются для изменения состояния промиса.

**Пример**:
```javascript
const myPromise = new Promise((resolve, reject) => {
    const success = true; // Условие успешного выполнения

    if (success) {
        resolve("Operation was successful!"); // Завершение промиса успешно
    } else {
        reject("Operation failed!"); // Отказ в промисе
    }
});
```

**Обработка Promise**

Для обработки результата или ошибки промиса используются методы `.then()` и `.catch()`.

- **`.then()`**: принимает функцию, которая будет вызвана при успешном завершении промиса.
- **`.catch()`**: принимает функцию, которая будет вызвана при отказе.

**Пример**:
```javascript
myPromise
    .then(result => {
        console.log(result); // "Operation was successful!"
    })
    .catch(error => {
        console.error(error); // Если промис отклонён
    });
```

**Пример с асинхронной операцией**

Ниже приведён пример, в котором используются `setTimeout` для имитации асинхронной операции, такой как HTTP-запрос:

```javascript
const fetchData = () => {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            const success = true; // Измените на false для тестирования отклонения

            if (success) {
                resolve("Data received!");
            } else {
                reject("Error fetching data!");
            }
        }, 2000); // Имитация задержки 2 секунды
    });
};

fetchData()
    .then(data => {
        console.log(data); // "Data received!"
    })
    .catch(error => {
        console.error(error); // "Error fetching data!"
    });
```

**Использование `async` и `await`**

С появлением `async` и `await` в ES2017 вы можете упростить обработку промисов, позволяя писать асинхронный код в более синхронном стиле.

**Пример**:
```javascript
const fetchDataWithAsync = async () => {
    try {
        const data = await fetchData(); // Ждём, пока промис выполнится
        console.log(data); // "Data received!"
    } catch (error) {
        console.error(error); // Обработка ошибок
    }
};

fetchDataWithAsync();
```

**Резюме**

- Promise представляет собой объект для обработки асинхронных операций в JavaScript.
- Создаются с помощью `new Promise()`, где определяются функции `resolve` и `reject`.
- Обрабатываются с использованием методов `.then()` и `.catch()`.
- `async/await` упрощает работу с промисами, позволяя писать асинхронный код в более удобной форме.


#### Вопрос 29. Какие состояния у Promise? 

Промисы (Promise) в JavaScript имеют три основных состояния:

1. **Pending (ожидание)**: Начальное состояние, когда промис ещё не завершён (ни выполнен, ни отклонён).
2. **Fulfilled (выполнен)**: Состояние, когда операция завершилась успешно, и промис получил результат.
3. **Rejected (отклонён)**: Состояние, когда операция завершилась с ошибкой, и промис получил причину отказа.

Давайте рассмотрим каждый из этих состояний с примерами.

1. **Pending (ожидание)**

Это начальное состояние промиса. В этом состоянии промис ещё не был выполнен или отклонён. Обычно это происходит во время выполнения асинхронной операции.

```javascript
const myPendingPromise = new Promise((resolve, reject) => {
    console.log("Promise is in pending state.");
    // Операция всё ещё выполняется
});

// Промис в ожидании
console.log(myPendingPromise); // Promise { <pending> }
```

2. **Fulfilled (выполнен)**

Когда асинхронная операция завершена успешно, промис переходит в состояние `fulfilled`. В этом состоянии используем метод `resolve()` для передачи результата.

**Пример**:
```javascript
const myFulfilledPromise = new Promise((resolve) => {
    setTimeout(() => {
        resolve("Operation completed successfully!");
    }, 2000); // Имитация задержки 2 секунды
});

// Обработка результата
myFulfilledPromise.then(result => {
    console.log(result); // "Operation completed successfully!"
});
```

3. **Rejected (отклонён)**

Когда асинхронная операция завершается с ошибкой, промис переходит в состояние `rejected`. В этом случае используется метод `reject()` для передачи причины ошибки.

**Пример**:
```javascript
const myRejectedPromise = new Promise((resolve, reject) => {
    setTimeout(() => {
        reject("Operation failed due to an error!");
    }, 2000); // Имитация задержки 2 секунды
});

// Обработка ошибки
myRejectedPromise.catch(error => {
    console.error(error); // "Operation failed due to an error!"
});
```

**Пример с использованием всех трёх состояний**

В одном примере можно объединить все три состояния, чтобы продемонстрировать, как промис переходит между ними.

```javascript
const myPromise = new Promise((resolve, reject) => {
    console.log("Promise is still pending...");

    const success = Math.random() > 0.5; // 50% шанс на успех

    setTimeout(() => {
        if (success) {
            resolve("Promise fulfilled: Operation completed successfully!");
        } else {
            reject("Promise rejected: Operation failed due to an error!");
        }
    }, 2000); // Имитация задержки 2 секунды
});

// Обработка результата и ошибки
myPromise
    .then(result => {
        console.log(result); // "Promise fulfilled: Operation completed successfully!" (если успешно)
    })
    .catch(error => {
        console.error(error); // "Promise rejected: Operation failed due to an error!" (если отклонён)
    });
```

**Резюме**

- **Pending**: начальное состояние, пока операция не завершена.
- **Fulfilled**: успешное завершение операции с результатом.
- **Rejected**: завершение операции с ошибкой.

Эти состояния помогают управлять асинхронным кодом и обрабатывать результаты выполнения операций.


#### Вопрос 30. Что такое `async/await`? Как обрабатывать ошибки?

`async/await` — это синтаксический сахар, введённый в JavaScript для работы с промисами, который позволяет писать асинхронный код более читаемым и понятным способом. `async` используется для объявления асинхронной функции, а `await` позволяет ждать завершения промиса.

**Основные особенности `async/await`**:

1. **Объявление функции как асинхронной**: Используя ключевое слово `async` перед определением функции, вы создаёте асинхронную функцию, которая всегда возвращает промис.
2. **Ожидание завершения промиса**: Внутри асинхронной функции можно использовать `await` для ожидания результата промиса. Код будет ждать, пока промис не выполнится или не отклонится.

**Пример использования `async/await`**:

```javascript
// Функция, возвращающая промис
const fetchData = () => {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve("Data received");
        }, 2000); // Имитация задержки 2 секунды
    });
};

// Асинхронная функция
const asyncFunction = async () => {
    console.log("Fetching data...");
    const data = await fetchData(); // Ожидаем завершения промиса
    console.log(data); // "Data received"
};

// Вызов асинхронной функции
asyncFunction();
```

**Обработка ошибок с `try/catch`**

`async/await` позволяет удобно обрабатывать ошибки при помощи блока `try/catch`. Если промис отклонён, выполнение перемещается в блок `catch`.

**Пример с обработкой ошибок**:

```javascript
const fetchDataWithError = () => {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            const error = Math.random() > 0.5; // 50% шанс на ошибку
            if (error) {
                reject("Error fetching data");
            } else {
                resolve("Data received");
            }
        }, 2000);
    });
};

// Асинхронная функция с обработкой ошибок
const asyncFunctionWithErrorHandling = async () => {
    try {
        console.log("Fetching data...");
        const data = await fetchDataWithError(); // Ожидаем завершения промиса
        console.log(data); // Если успешно
    } catch (error) {
        console.error(error); // Обработка ошибки
    }
};

// Вызов асинхронной функции
asyncFunctionWithErrorHandling();
```

**Пример с несколькими асинхронными операциями**:

```javascript
const fetchAnotherData = () => {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve("Another data received");
        }, 1000); // Имитация задержки 1 секунда
    });
};

// Асинхронная функция, использующая несколько промисов
const asyncFunctionMultiplePromises = async () => {
    try {
        console.log("Fetching first data...");
        const firstData = await fetchData(); // Ждём первое получение данных
        console.log(firstData); // "Data received"

        console.log("Fetching second data...");
        const secondData = await fetchAnotherData(); // Ждём второе получение данных
        console.log(secondData); // "Another data received"
    } catch (error) {
        console.error(error); // Обработка ошибок
    }
};

// Вызов асинхронной функции
asyncFunctionMultiplePromises();
```

**Резюме**

- `async/await` позволяет писать асинхронный код более понятно и удобно.
- Ключевое слово `async` перед функцией делает её асинхронной и возвращает промис.
- `await` приостанавливает выполнение кода до завершения промиса, что позволяет избежать вложенности промисов.
- Ошибки можно обрабатывать в асинхронных функциях с использованием блоков `try/catch`.


#### Вопрос 31. Как выполнить несколько Promise параллельно? (`Promise.all`, `Promise.race` и др.)

В JavaScript можно выполнять несколько промисов параллельно, используя несколько методов, таких как `Promise.all`, `Promise.race`, `Promise.allSettled` и `Promise.any`. Каждый из этих методов имеет своё предназначение и поведение. Давайте рассмотрим их по порядку.

1. **`Promise.all`**

`Promise.all` принимает массив промисов и возвращает новый промис, который будет выполнен, когда все промисы в массиве будут выполнены. Если любой из промисов отклонится, то `Promise.all` отклонится с причиной первого отклонённого промиса.

**Пример**:
```javascript
const promise1 = new Promise((resolve) => setTimeout(resolve, 1000, "Result from Promise 1"));
const promise2 = new Promise((resolve) => setTimeout(resolve, 2000, "Result from Promise 2"));
const promise3 = new Promise((resolve) => setTimeout(resolve, 1500, "Result from Promise 3"));

Promise.all([promise1, promise2, promise3])
    .then((results) => {
        console.log(results); // ["Result from Promise 1", "Result from Promise 2", "Result from Promise 3"]
    })
    .catch((error) => {
        console.error("One of the promises failed:", error);
    });
```

2. **`Promise.race`**

`Promise.race` также принимает массив промисов и возвращает новый промис, который будет выполнен или отклонен в зависимости от первого завершённого промиса — будь то выполненный или отклонённый.

**Пример**:
```javascript
const promise1 = new Promise((resolve) => setTimeout(resolve, 1000, "Result from Promise 1"));
const promise2 = new Promise((resolve) => setTimeout(resolve, 500, "Result from Promise 2"));
const promise3 = new Promise((resolve, reject) => setTimeout(reject, 800, "Error from Promise 3"));

Promise.race([promise1, promise2, promise3])
    .then((result) => {
        console.log("First completed promise:", result); // "Result from Promise 2"
    })
    .catch((error) => {
        console.error("Race failed with error:", error); // "Error from Promise 3" (если произойдёт)
    });
```

3. **`Promise.allSettled`**

`Promise.allSettled` принимает массив промисов и возвращает промис, который выполнится, когда все промисы завершатся, независимо от их состояний (выполнены или отклонены). Он возвращает массив объектов, содержащих статус и значение (или причину отказа) каждого промиса.

**Пример**:
```javascript
const promise1 = new Promise((resolve) => setTimeout(resolve, 1000, "Result from Promise 1"));
const promise2 = new Promise((resolve, reject) => setTimeout(reject, 500, "Error from Promise 2"));
const promise3 = new Promise((resolve) => setTimeout(resolve, 1500, "Result from Promise 3"));

Promise.allSettled([promise1, promise2, promise3])
    .then((results) => {
        results.forEach((result) => {
            console.log(result);
        });
    });
```

**Вывод**:
```
{ status: 'fulfilled', value: 'Result from Promise 1' }
{ status: 'rejected', reason: 'Error from Promise 2' }
{ status: 'fulfilled', value: 'Result from Promise 3' }
```

4. **`Promise.any`**

`Promise.any` принимает массив промисов и возвращает новый промис, который будет выполнен, как только первый из промисов будет выполнен. Если все промисы отклонены, будет возвращена ошибка.

**Пример**:
```javascript
const promise1 = new Promise((resolve, reject) => setTimeout(reject, 1000, "Error from Promise 1"));
const promise2 = new Promise((resolve) => setTimeout(resolve, 500, "Result from Promise 2"));
const promise3 = new Promise((resolve, reject) => setTimeout(reject, 700, "Error from Promise 3"));

Promise.any([promise1, promise2, promise3])
    .then((result) => {
        console.log("First fulfilled promise:", result); // "Result from Promise 2"
    })
    .catch((error) => {
        console.error("All promises were rejected:", error);
    });
```

**Резюме**

- **`Promise.all`**: выполняется, когда все промисы выполнены; отклоняется при первом отклонённом промисе.
- **`Promise.race`**: выполняется или отклоняется при первом завершённом промисе.
- **`Promise.allSettled`**: выполняется, когда все промисы завершены, возвращает их статус и результаты.
- **`Promise.any`**: выполняется, когда первый промис выполнен; отклоняется, если все промисы отклонены.


#### Вопрос 32. Что такое AJAX? Как сделать HTTP-запрос?

AJAX (Asynchronous JavaScript and XML) — это набор методов и технологий, который позволяет веб-приложениям асинхронно обмениваться данными с сервером без перезагрузки страницы. Хотя название содержит "XML", AJAX в основном используется для работы с форматами JSON, HTML и другими.

**Как сделать HTTP-запрос с использованием AJAX**

В JavaScript HTTP-запросы можно выполнять несколькими способами. Наиболее часто используемыми методами являются использование `XMLHttpRequest` и `Fetch API`. Рассмотрим оба подхода.

1. **Использование `XMLHttpRequest`**

Это старый способ выполнения AJAX-запросов. Вот пример:

```javascript
const xhr = new XMLHttpRequest();
xhr.open("GET", "https://jsonplaceholder.typicode.com/posts", true); // Настраиваем запрос

xhr.onload = function() {
    if (xhr.status >= 200 && xhr.status < 300) {
        const response = JSON.parse(xhr.responseText); // Парсим ответ
        console.log(response); // Выводим данные в консоль
    } else {
        console.error("Request failed with status:", xhr.status); // Обработка ошибок
    }
};

xhr.onerror = function() {
    console.error("Request failed"); // Обработка ошибок сети
};

xhr.send(); // Отправляем запрос
```

2. **Использование `Fetch API`**

`Fetch API` — это более современный и удобный способ выполнения HTTP-запросов. Он возвращает обещание (Promise), что делает его более подходящим для работы с асинхронным кодом.

**Пример получения данных с использованием Fetch**:

```javascript
fetch("https://jsonplaceholder.typicode.com/posts")
    .then((response) => {
        if (!response.ok) {
            throw new Error("Network response was not ok: " + response.statusText);
        }
        return response.json(); // Парсим ответ в формате JSON
    })
    .then((data) => {
        console.log(data); // Выводим полученные данные
    })
    .catch((error) => {
        console.error("Fetch error:", error); // Обработка ошибок
    });
```

**Пример отправки данных с использованием POST-запроса**:

```javascript
const postData = {
    title: "foo",
    body: "bar",
    userId: 1,
};

fetch("https://jsonplaceholder.typicode.com/posts", {
    method: "POST", // Указываем метод
    headers: {
        "Content-Type": "application/json", // Указываем тип контента
    },
    body: JSON.stringify(postData), // Преобразуем объект в JSON
})
    .then((response) => {
        if (!response.ok) {
            throw new Error("Network response was not ok: " + response.statusText);
        }
        return response.json(); // Парсим ответ в формате JSON
    })
    .then((data) => {
        console.log("Data posted successfully:", data); // Выводим ответ сервера
    })
    .catch((error) => {
        console.error("Fetch error:", error); // Обработка ошибок
    });
```

**Резюме**

- **AJAX** позволяет асинхронно обмениваться данными с сервером без перезагрузки страницы.
- **`XMLHttpRequest`** — старый способ выполнения HTTP-запросов.
- **`Fetch API`** — современный способ выполнения HTTP-запросов, который возвращает промис и обеспечивает более удобный и читаемый синтаксис.


#### Вопрос 33. Какие есть методы HTTP-запросов?

HTTP (Hypertext Transfer Protocol) поддерживает несколько методов запросов, каждая из которых предназначена для выполнения определённых операций с ресурсами на сервере. Наиболее распространённые методы включают `GET`, `POST`, `PUT`, `DELETE`, `PATCH`, `HEAD` и `OPTIONS`. Давайте рассмотрим каждый из этих методов и приведем примеры.

1. **GET**

Метод `GET` используется для запроса данных с сервера. Данные обычно передаются через URL.

**Пример**:
```javascript
fetch("https://jsonplaceholder.typicode.com/posts/1")
    .then((response) => response.json())
    .then((data) => {
        console.log(data); // Полученные данные
    })
    .catch((error) => {
        console.error("Error:", error);
    });
```

2. **POST**

Метод `POST` используется для отправки данных на сервер. Обычно используется для создания новых ресурсов.

**Пример**:
```javascript
const postData = {
    title: "foo",
    body: "bar",
    userId: 1,
};

fetch("https://jsonplaceholder.typicode.com/posts", {
    method: "POST",
    headers: {
        "Content-Type": "application/json",
    },
    body: JSON.stringify(postData),
})
    .then((response) => response.json())
    .then((data) => {
        console.log("Data posted successfully:", data);
    })
    .catch((error) => {
        console.error("Error:", error);
    });
```

3. **PUT**

Метод `PUT` используется для передачи данных на сервер в целях обновления существующего ресурса. В отличие от `PATCH`, который вносит частичные изменения, `PUT` заменяет весь ресурс.

**Пример**:
```javascript
const updatedData = {
    title: "foo",
    body: "updated text",
    userId: 1,
};

fetch("https://jsonplaceholder.typicode.com/posts/1", {
    method: "PUT",
    headers: {
        "Content-Type": "application/json",
    },
    body: JSON.stringify(updatedData),
})
    .then((response) => response.json())
    .then((data) => {
        console.log("Data updated successfully:", data);
    })
    .catch((error) => {
        console.error("Error:", error);
    });
```

4. **DELETE**

Метод `DELETE` используется для удаления ресурса на сервере.

**Пример**:
```javascript
fetch("https://jsonplaceholder.typicode.com/posts/1", {
    method: "DELETE",
})
    .then((response) => {
        if (response.ok) {
            console.log("Resource deleted successfully");
        } else {
            throw new Error("Delete request failed");
        }
    })
    .catch((error) => {
        console.error("Error:", error);
    });
```

5. **PATCH**

Метод `PATCH` используется для частичного обновления существующего ресурса.

**Пример**:
```javascript
const partialUpdateData = {
    body: "partially updated text",
};

fetch("https://jsonplaceholder.typicode.com/posts/1", {
    method: "PATCH",
    headers: {
        "Content-Type": "application/json",
    },
    body: JSON.stringify(partialUpdateData),
})
    .then((response) => response.json())
    .then((data) => {
        console.log("Data partially updated successfully:", data);
    })
    .catch((error) => {
        console.error("Error:", error);
    });
```

6. **HEAD**

Метод `HEAD` выполняет запрос на сервер, но возвращает только заголовки ответа, без тела. Обычно используется для проверки доступности ресурса.

**Пример**:
```javascript
fetch("https://jsonplaceholder.typicode.com/posts/1", {
    method: "HEAD",
})
    .then((response) => {
        console.log("Response headers:", response.headers);
    })
    .catch((error) => {
        console.error("Error:", error);
    });
```

7. **OPTIONS**

Метод `OPTIONS` используется для запроса информации о доступных методах и параметрах для конкретного ресурса. Обычно используется для настройки CORS (Cross-Origin Resource Sharing).

**Пример**:
```javascript
fetch("https://jsonplaceholder.typicode.com/posts/1", {
    method: "OPTIONS",
})
    .then((response) => {
        console.log("Allowed methods:", response.headers.get("Allow"));
    })
    .catch((error) => {
        console.error("Error:", error);
    });
```

**Резюме**

- **GET**: Запрос данных с сервера.
- **POST**: Отправка данных на сервер для создания нового ресурса.
- **PUT**: Обновление существующего ресурса.
- **DELETE**: Удаление ресурса.
- **PATCH**: Частичное обновление ресурса.
- **HEAD**: Получение заголовков ответа без тела.
- **OPTIONS**: Запрос доступных методов для ресурса.

#### Вопрос 34. Как работать с `fetch`? 

`fetch` — это современный API для выполнения HTTP-запросов в JavaScript. Он позволяет осуществлять асинхронные запросы, возвращая промис, который можно использовать для обработки ответа.

Вот основные моменты, которые нужно знать о `fetch`, а затем приведём примеры использования.

**Основные особенности `fetch`**:

1. `fetch()` принимает URL как обязательный аргумент и опционально принимает объект параметров для настройки запроса.
2. Возвращает промис, который разрешается в объект `Response`, представляющий ответ на запрос.
3. Методы для извлечения данных из `Response`: `json()`, `text()`, `blob()`, `formData()`, и `arrayBuffer()`.
4. Не выбрасывает исключение для HTTP-статусов 4xx и 5xx; необходимо явно проверять `response.ok`.

**Примеры использования `fetch`**:

1. **GET-запрос**

**Пример получения данных**:
```javascript
fetch("https://jsonplaceholder.typicode.com/posts/1")
    .then((response) => {
        if (!response.ok) {
            throw new Error("Network response was not ok");
        }
        return response.json(); // Парсим ответ в JSON
    })
    .then((data) => {
        console.log(data); // Выводим полученные данные
    })
    .catch((error) => {
        console.error("Fetch error:", error);
    });
```

2. **POST-запрос**

**Пример отправки данных**:
```javascript
const postData = {
    title: "foo",
    body: "bar",
    userId: 1,
};

fetch("https://jsonplaceholder.typicode.com/posts", {
    method: "POST", // Указываем метод
    headers: {
        "Content-Type": "application/json", // Указываем тип контента
    },
    body: JSON.stringify(postData), // Преобразуем объект в JSON
})
    .then((response) => {
        if (!response.ok) {
            throw new Error("Network response was not ok");
        }
        return response.json(); // Парсим ответ в JSON
    })
    .then((data) => {
        console.log("Data posted successfully:", data); // Выводим ответ сервера
    })
    .catch((error) => {
        console.error("Fetch error:", error);
    });
```

3. **PUT-запрос**

**Пример обновления данных**:
```javascript
const updatedData = {
    title: "foo",
    body: "updated text",
    userId: 1,
};

fetch("https://jsonplaceholder.typicode.com/posts/1", {
    method: "PUT", // Указываем метод
    headers: {
        "Content-Type": "application/json",
    },
    body: JSON.stringify(updatedData), // Преобразуем объект в JSON
})
    .then((response) => {
        if (!response.ok) {
            throw new Error("Network response was not ok");
        }
        return response.json(); // Парсим ответ в JSON
    })
    .then((data) => {
        console.log("Data updated successfully:", data);
    })
    .catch((error) => {
        console.error("Fetch error:", error);
    });
```

4. **DELETE-запрос**

**Пример удаления данных**:
```javascript
fetch("https://jsonplaceholder.typicode.com/posts/1", {
    method: "DELETE", // Указываем метод
})
    .then((response) => {
        if (response.ok) {
            console.log("Resource deleted successfully");
        } else {
            throw new Error("Delete request failed");
        }
    })
    .catch((error) => {
        console.error("Fetch error:", error);
    });
```

5. **Обработка ошибок**

В случае ошибок сетевого запроса можно использовать блок `catch`, чтобы обработать ошибки. Следует также всегда проверять `response.ok` для обработки возможных ошибок на сервере.

**Резюме**

`fetch` предоставляет простой и удобный способ для выполнения HTTP-запросов в JavaScript. Он поддерживает различные методы, включая `GET`, `POST`, `PUT`, и `DELETE`, а также позволяет настраивать заголовки и тело запросов. 



#### Вопрос 35. Что такое CORS? Как обойти ограничения?

CORS (Cross-Origin Resource Sharing) — это механизм безопасности, который позволяет или запрещает веб-приложениям, работающим на одном домене, запрашивать ресурсы с другого домена. Этот механизм помогает предотвратить атаки злоумышленников, такие как CSRF (Cross-Site Request Forgery).

**Как работает CORS?**

Когда веб-страница пытается сделать HTTP-запрос к ресурсам на другом домене (например, с `http://example.com` к `http://api.example.com`), браузер автоматически добавляет заголовок `Origin` к запросу. Сервер, обрабатывающий этот запрос, должен явным образом разрешить доступ к своим ресурсам, добавив заголовок `Access-Control-Allow-Origin` в ответ.

**Пример CORS**

- **Запрос**:
```http
GET /resource HTTP/1.1
Host: api.example.com
Origin: http://example.com
```

- **Ответ**:
```http
HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://example.com
```

Если сервер не возвращает заголовок `Access-Control-Allow-Origin` с указанием источника, запрашивающее приложение не сможет получить доступ к ресурсу, и браузер заблокирует ответ.

**Как обойти ограничения CORS?**

Обходить ограничения CORS не рекомендуется, поскольку это может привести к нарушению безопасности приложения. Однако, если вы управляете сервером или у вас есть разрешение, вы можете следовать некоторым подходам для настройки CORS.

1. **Настройка сервера для разрешения CORS**

Если вы контролируете сервер, добавьте нужные заголовки CORS в свои ответы. Например, для Node.js с использованием Express можно сделать так:

```javascript
const express = require('express');
const cors = require('cors');

const app = express();
app.use(cors()); // Разрешаем CORS для всех источников

app.get('/resource', (req, res) => {
    res.json({ message: 'Hello from CORS-enabled server!' });
});

app.listen(3000, () => {
    console.log('Server is running on port 3000');
});
```

С помощью библиотеки `cors`, вы можете настроить разрешения, передав параметры, чтобы ограничить доступ только для определённых источников.

2. **Использование прокси-сервера**

Вы можете настроить прокси-сервер, который будет выступать посредником между клиентом и сервером. Это позволит избежать проблем с CORS (поскольку запрос будет отправляться к вашему прокси-серверу, а не напрямую к другому домену).

**Пример на Node.js с использованием `http-proxy-middleware`**:
```javascript
const express = require('express');
const { createProxyMiddleware } = require('http-proxy-middleware');

const app = express();

app.use('/api', createProxyMiddleware({
    target: 'http://api.example.com',
    changeOrigin: true,
}));

app.listen(3000, () => {
    console.log('Proxy server is running on port 3000');
});
```

3. **Использование JSONP (только для GET-запросов)**

JSONP (JSON with Padding) — это старый метод обхода ограничений CORS, который использует теги `<script>` для выполнения запросов. Однако этот метод поддерживает только GET-запросы.

**Пример JSONP**:
```html
<script>
function handleResponse(data) {
    console.log(data); // Обработка ответа
}

const script = document.createElement('script');
script.src = "http://api.example.com/resource?callback=handleResponse"; // Указываем функцию обратного вызова
document.body.appendChild(script);
</script>
```

**Резюме**

- CORS — это механизм безопасности, который позволяет контролировать доступ к ресурсам между различными доменами.
- Чтобы обойти ограничения CORS, вы можете настраивать сервер для разрешения нужных заголовков, использовать прокси-сервер или применять JSONP (только для GET).
- Важно помнить о безопасности и не пытаться обойти CORS через несанкционированные методы.


---

### Работа с DOM

#### Вопрос 36. Что такое DOM? 

DOM (Document Object Model) — это интерфейс программирования для веб-документов. Он представляет структуру документа в виде дерева, где каждый элемент HTML или XML представлен как объект. DOM позволяет программам и скриптам динамически изменять содержание, структуру и стили документа.

**Основные особенности DOM**:

1. **Структура дерева**: Все элементы, текст и атрибуты документа представляются как узлы в дереве. Корень дерева — это объект `document`.

2. **Язык независимости**: Хотя DOM часто используется с JavaScript, он не привязан к конкретному языку программирования. Многие языки могут работать с DOM.

3. **Динамическое изменение**: DOM позволяет изменять содержимое и структуру веб-страницы после её загрузки, создавая интерактивный пользовательский интерфейс.

**Примеры работы с DOM в JavaScript**:

1. **Получение элементов**

Вы можете получить элементы документа с помощью различных методов.

**Пример**:
```javascript
// Получаем элемент по ID
const header = document.getElementById('header');

// Получаем элементы по классу
const items = document.getElementsByClassName('item');

// Получаем элементы по селектору CSS
const buttons = document.querySelectorAll('.button');
```

2. **Изменение содержимого**

Используя свойства объектов DOM, можно изменять содержимое элементов.

**Пример**:
```javascript
const header = document.getElementById('header');
header.textContent = "Новый заголовок"; // Изменяем текст заголовка

const paragraph = document.querySelector('p');
paragraph.innerHTML = "<strong>Этот текст будет выделен</strong>"; // Изменяем HTML содержимое
```

3. **Изменение стилей**

Вы также можете изменять стили элементов, используя свойство `style`.

**Пример**:
```javascript
const button = document.querySelector('.button');
button.style.backgroundColor = "blue"; // Меняем цвет фона кнопки
button.style.color = "white"; // Меняем цвет текста
```

4. **Добавление и удаление элементов**

DOM позволяет добавлять и удалять элементы из документа.

**Пример добавления элемента**:
```javascript
const newDiv = document.createElement('div'); // Создаем новый элемент
newDiv.textContent = "Новый элемент"; // Задаем текст
document.body.appendChild(newDiv); // Добавляем в конец документа
```

**Пример удаления элемента**:
```javascript
const elementToDelete = document.getElementById('toDelete'); // Находим элемент
elementToDelete.parentNode.removeChild(elementToDelete); // Удаляем элемент
```

5. **Обработка событий**

DOM позволяет реагировать на действия пользователя, такие как клики, ввод текста и т.д.

**Пример**:
```javascript
const button = document.querySelector('.button');
button.addEventListener('click', () => {
    alert("Кнопка нажата!"); // Отображаем сообщение при нажатии кнопки
});
```

**Резюме**

- **DOM** — это объектная модель, представляющая структуру HTML или XML документа как дерево узлов.
- Вы можете использовать JavaScript для манипуляции DOM: получать, изменять, добавлять и удалять элементы, а также обрабатывать события.


#### Вопрос 37. Как найти элемент на странице? (`getElementById`, `querySelector` и др.) 

В JavaScript для поиска элементов на странице можно использовать несколько методов. Каждый из них предоставляет различные способы доступа к элементам DOM в зависимости от ваших нужд. Вот основные из них:

1. **`getElementById`**

Метод `getElementById` находит элемент по его уникальному идентификатору. Этот метод возвращает единственный элемент, так как идентификатор должен быть уникальным на странице.

**Пример**:
```html
<div id="myElement">Привет, мир!</div>
<script>
const element = document.getElementById('myElement');
console.log(element.textContent); // Выводит: "Привет, мир!"
</script>
```

2. **`getElementsByClassName`**

Метод `getElementsByClassName` возвращает коллекцию элементов, которые имеют заданный класс. Это не массив, а "живую" коллекцию, т.е. она обновляется автоматически при изменении DOM.

**Пример**:
```html
<div class="item">Элемент 1</div>
<div class="item">Элемент 2</div>
<div class="item">Элемент 3</div>
<script>
const items = document.getElementsByClassName('item');
console.log(items.length); // Выводит: 3
console.log(items[0].textContent); // Выводит: "Элемент 1"
</script>
```

3. **`getElementsByTagName`**

Метод `getElementsByTagName` возвращает коллекцию всех элементов с указанным тегом.

**Пример**:
```html
<p>Первый параграф</p>
<p>Второй параграф</p>
<script>
const paragraphs = document.getElementsByTagName('p');
console.log(paragraphs.length); // Выводит: 2
console.log(paragraphs[1].textContent); // Выводит: "Второй параграф"
</script>
```

4. **`querySelector`**

Метод `querySelector` возвращает первый элемент, который соответствует указанному CSS-селектору. Это универсальный метод, позволяющий использовать любую комбинацию селекторов.

**Пример**:
```html
<div class="content">
    <p class="text">Hello, world!</p>
</div>
<script>
const paragraph = document.querySelector('.content .text');
console.log(paragraph.textContent); // Выводит: "Hello, world!"
</script>
```

5. **`querySelectorAll`**

Метод `querySelectorAll` возвращает все элементы, которые соответствуют указанному CSS-селектору, в виде статической коллекции (NodeList).

**Пример**:
```html
<div class="box">Куб 1</div>
<div class="box">Куб 2</div>
<div class="box">Куб 3</div>
<script>
const boxes = document.querySelectorAll('.box');
console.log(boxes.length); // Выводит: 3
boxes.forEach((box, index) => {
    console.log(`Куб ${index + 1}: ${box.textContent}`); // Выводит текст каждого куба
});
</script>
```

6. **`parentNode` и `children`**

Вы также можете находить элементы относительно других элементов, используя свойства `parentNode` и `children`.

**Пример**:
```html
<div id="parent">
    <p class="child">Дочерний элемент 1</p>
    <p class="child">Дочерний элемент 2</p>
</div>
<script>
const parent = document.getElementById('parent');
const children = parent.children;
console.log(children.length); // Выводит: 2
console.log(children[0].textContent); // Выводит: "Дочерний элемент 1"
</script>
```

**Резюме**

В JavaScript есть множество методов для поиска элементов на странице, включая `getElementById`, `getElementsByClassName`, `getElementsByTagName`, `querySelector` и `querySelectorAll`. Выбор метода зависит от того, какую задачу вы решаете: хотите ли вы найти один элемент или несколько, и как именно вы хотите их идентифицировать.


#### Вопрос 38. Как создать новый элемент и добавить его в DOM? 

В JavaScript создание нового элемента и добавление его в DOM можно выполнить с использованием методов, таких как `document.createElement()` и `appendChild()`. Вот шаги и примеры, которые помогут вам понять данный процесс.

**Шаги для создания нового элемента и его добавления в DOM**:

1. **Создайте новый элемент с помощью `document.createElement()`.**
2. **Установите свойства или содержимое для созданного элемента (если необходимо).**
3. **Добавьте созданный элемент в нужное место в DOM с использованием методов, таких как `appendChild()`, `insertBefore()`, или `replaceChild()`.**

**Примеры создания и добавления элементов в DOM**:

1. **Простой пример добавления элемента**

**Пример**:
```html
<div id="container"></div>
<script>
    // Шаг 1: Создаём новый элемент
    const newDiv = document.createElement('div');

    // Шаг 2: Устанавливаем содержимое и другие свойства
    newDiv.textContent = 'Это новый элемент';
    newDiv.style.backgroundColor = 'lightblue'; // Задаём стиль

    // Шаг 3: Находим элемент, в который нужно добавить новый элемент
    const container = document.getElementById('container');

    // Шаг 4: Добавляем новый элемент в DOM
    container.appendChild(newDiv);
</script>
```

2. **Добавление нескольких элементов**

**Пример**:
```html
<ul id="list"></ul>
<script>
    const list = document.getElementById('list');

    // Создаем массив с данными
    const items = ['Элемент 1', 'Элемент 2', 'Элемент 3'];

    items.forEach(item => {
        // Создаем новый элемент списка
        const listItem = document.createElement('li');
        listItem.textContent = item; // Устанавливаем текст
        list.appendChild(listItem); // Добавляем элемент в список
    });
</script>
```

3. **Вставка элемента перед другим элементом**

**Пример**:
```html
<div id="parent">
    <p id="reference">Это ссылка</p>
</div>
<script>
    // Создаём новый элемент
    const newParagraph = document.createElement('p');
    newParagraph.textContent = 'Это новый параграф';

    // Находим родительский элемент и ссылку
    const parent = document.getElementById('parent');
    const reference = document.getElementById('reference');

    // Вставляем новый элемент перед ссылкой
    parent.insertBefore(newParagraph, reference);
</script>
```

4. **Замена существующего элемента**

**Пример**:
```html
<div id="container">
    <p id="oldElement">Старый элемент</p>
</div>
<script>
    // Создаём новый элемент
    const newElement = document.createElement('p');
    newElement.textContent = 'Это новый элемент, заменяющий старый';

    // Находим старый элемент
    const oldElement = document.getElementById('oldElement');

    // Заменяем старый элемент новым
    oldElement.parentNode.replaceChild(newElement, oldElement);
</script>
```

**Резюме**

В JavaScript создание новых элементов и их добавление в DOM осуществляется через методы `document.createElement()`, `appendChild()`, `insertBefore()` и `replaceChild()`. Эти методы предоставляют гибкие возможности для динамического изменения контента веб-страницы.


#### Вопрос 39. Как изменить стиль элемента через JavaScript?

В JavaScript можно изменять стиль элемента, обращаясь к его свойствам через объект `style`. Давайте рассмотрим, как это сделать, а также приведём несколько примеров.

**Основные способы изменения стилей элементов**:

1. **Прямое изменение через свойство `style`**.
2. **Добавление или удаление классов с помощью `classList`**.
3. **Использование алерта стилей через CSS в JavaScript, добавляя или изменяя атрибуты.**

**Примеры изменения стилей элемента**:

1. **Прямое изменение стилей через `style`**

**Пример**:
```html
<div id="myElement" style="width: 100px; height: 100px; background-color: red;"></div>
<button id="changeStyle">Изменить стиль</button>

<script>
    document.getElementById('changeStyle').onclick = function() {
        const element = document.getElementById('myElement');
        // Изменяем стиль элемента
        element.style.backgroundColor = 'blue'; // Меняем цвет фона
        element.style.width = '200px'; // Меняем ширину
        element.style.height = '200px'; // Меняем высоту
    };
</script>
```

В этом примере, при нажатии на кнопку, цвет фона, ширина и высота div изменятся.

2. **Изменение стилей с помощью `classList`**

Метод `classList` позволяет добавлять, удалять и переключать классы CSS у элементов. Это удобно, если у вас есть заранее определенные стили в CSS.

**Пример**:
```html
<style>
    .newStyle {
        background-color: yellow;
        width: 150px;
        height: 150px;
    }
</style>

<div id="myElement" class="box" style="width: 100px; height: 100px; background-color: red;"></div>
<button id="applyClass">Применить класс</button>

<script>
    document.getElementById('applyClass').onclick = function() {
        const element = document.getElementById('myElement');
        // Добавляем новый класс
        element.classList.add('newStyle');
    };
</script>
```

В этом примере при нажатии на кнопку элемент получит новый стиль, определенный в классе `newStyle`.

3. **Удаление стилей**

Вы также можете удалять стили у элемента, устанавливая свойства в пустое значение или удаляя класс.

**Пример**:
```html
<style>
    .highlight {
        background-color: green;
    }
</style>

<div id="myElement" class="box highlight" style="width: 100px; height: 100px;"></div>
<button id="removeStyle">Удалить стиль</button>

<script>
    document.getElementById('removeStyle').onclick = function() {
        const element = document.getElementById('myElement');
        // Удаляем класс
        element.classList.remove('highlight');
        // Можно также удалить инлайн-стили
        element.style.width = '';
        element.style.height = '';
    };
</script>
```

При нажатии на кнопку у элемента будет удален класс `highlight`, и установленные стили также будут сброшены.

4. **Изменение нескольких стилей**

Можно устанавливать несколько стилей одновременно, используя объект стилей.

**Пример**:
```html
<div id="myElement" style="width: 100px; height: 100px; background-color: red;"></div>
<button id="changeAllStyles">Изменить все стили</button>

<script>
    document.getElementById('changeAllStyles').onclick = function() {
        const element = document.getElementById('myElement');
        
        // Меняем несколько стилей одновременно
        Object.assign(element.style, {
            backgroundColor: 'purple',
            width: '300px',
            height: '300px',
        });
    };
</script>
```

**Резюме**

Вы можете изменять стиль элемента в JavaScript, используя свойство `style` для прямого изменения стилей, `classList` для управления классами CSS, а также с помощью метода `Object.assign` для изменения нескольких стилей одновременно. Это позволяет гибко управлять внешним видом элементов на странице.


#### Вопрос 40. Как обработать событие клика на кнопке? 

В JavaScript обработка события клика на кнопке осуществляется с использованием метода `addEventListener()` или через атрибут `onclick` элемента. Рассмотрим оба способа и приведем примеры.

1. **Использование `addEventListener()`**

Метод `addEventListener()` добавляет обработчик события к элементу, что позволяет отслеживать различные события, такие как клики, наведение и т.д.

**Пример**:
```html
<button id="myButton">Нажми меня!</button>

<script>
    const button = document.getElementById('myButton');

    // Добавляем обработчик события клика
    button.addEventListener('click', function() {
        alert('Кнопка нажата!'); // Показать уведомление при клике
    });
</script>
```

2. **Использование атрибута `onclick`**

Вы можете установить обработчик события непосредственно через атрибут `onclick` в HTML. Однако этот способ менее предпочтителен, так как он смешивает HTML и JavaScript.

**Пример**:
```html
<button id="myButton" onclick="handleClick()">Нажми меня!</button>

<script>
    function handleClick() {
        alert('Кнопка нажата!'); // Показать уведомление при клике
    }
</script>
```

3. **Обработка события клика с использованием стрелочной функции**

Вы можете использовать стрелочные функции для более компактной записи обработчиков событий.

**Пример**:
```html
<button id="myButton">Нажми меня!</button>

<script>
    const button = document.getElementById('myButton');

    // Используем стрелочную функцию в качестве обработчика
    button.addEventListener('click', () => {
        alert('Кнопка нажата!');
    });
</script>
```

4. **Передача параметров в обработчик**

Если вам нужно передать параметры в функцию-обработчик, вы можете использовать обертку.

**Пример**:
```html
<button id="myButton">Нажми меня!</button>

<script>
    const button = document.getElementById('myButton');

    // Обертка для передачи параметров
    button.addEventListener('click', (event) => handleClick(event, 'Кнопка нажата!'));

    function handleClick(event, message) {
        alert(message); // Показать переданное сообщение
    }
</script>
```

5. **Удаление обработчика события**

Если вам нужно удалить обработчик события, вы можете сделать это с помощью метода `removeEventListener()`.

**Пример**:
```html
<button id="myButton">Нажми меня!</button>
<button id="removeButton">Удалить обработчик</button>

<script>
    const button = document.getElementById('myButton');
    const removeButton = document.getElementById('removeButton');

    function handleClick() {
        alert('Кнопка нажата!');
    }

    button.addEventListener('click', handleClick);

    // Удаляем обработчик события
    removeButton.addEventListener('click', () => {
        button.removeEventListener('click', handleClick);
        alert('Обработчик события удален!');
    });
</script>
```

**Резюме**

Обработку события клика на кнопке можно выполнить разными способами в JavaScript, включая использование `addEventListener()` и атрибута `onclick`. Выбор способа зависит от ваших предпочтений и требований к структуре кода. Использование `addEventListener()` является более предпочтительным, поскольку позволяет разделять логику и структуру.

#### Вопрос 41. Что такое Event Bubbling и Event Capturing?

В JavaScript события могут обрабатываться двумя способами: **Event Bubbling** (всплытие событий) и **Event Capturing** (погружение событий). Оба метода относятся к тому, как события распространяются по DOM-дереву.

1. **Event Bubbling (Всплытие событий)**

Event Bubbling — это процесс, при котором событие начинает с самого целевого элемента (где произошло событие) и «всплывает» вверх к родительским элементам. Это означает, что сначала обрабатываются обработчики событий на нижнем уровне и постепенно поднимаются к родителям.

**Пример**:
```html
<div id="parent" style="padding: 20px; background-color: lightgray;">
    Родительский элемент
    <button id="child">Нажми меня!</button>
</div>

<script>
    document.getElementById('parent').addEventListener('click', () => {
        alert('Клик на родительском элементе!');
    });

    document.getElementById('child').addEventListener('click', () => {
        alert('Клик на дочернем элементе!');
    });
</script>
```

В этом примере, когда вы нажимаете кнопку, сначала сработает обработчик на дочернем элементе, а затем сработает обработчик на родительском элементе, что вызовет два алерта.

2. **Event Capturing (Погружение событий)**

Event Capturing, наоборот, — это процесс, при котором событие начинает с самого верхнего уровня DOM и двигается вниз к целевому элементу. Сначала обрабатывается обработчик события на родительском элементе, а затем на дочернем.

Для того чтобы использовать Capturing, необходимо указать третий параметр в `addEventListener`, который устанавливается в значение `true`.

**Пример**:
```html
<div id="parent" style="padding: 20px; background-color: lightgray;">
    Родительский элемент
    <button id="child">Нажми меня!</button>
</div>

<script>
    document.getElementById('parent').addEventListener('click', () => {
        alert('Клик на родительском элементе! (Capturing)');
    }, true); // Указываем true для активации Capturing

    document.getElementById('child').addEventListener('click', () => {
        alert('Клик на дочернем элементе!');
    });
</script>
```

В этом примере, когда вы нажмете кнопку, сначала сработает обработчик на родительском элементе (capturing), а затем на дочернем элементе.

3. **Различия между Event Bubbling и Event Capturing**

- **Порядок обработки**:
  - Bubbling: Сначала обрабатывается целевой элемент, затем его родительские элементы.
  - Capturing: Сначала обрабатываются родительские элементы, затем целевой элемент.

- **Способ указания**: В Bubbling это поведение происходит по умолчанию. Для Capturing необходимо явно указать его с помощью третьего параметра в `addEventListener`.

4. **Пример с обоими подходами**

**Пример**:
```html
<div id="parent" style="padding: 20px; background-color: lightgray;">
    Родительский элемент
    <button id="child">Нажми меня!</button>
</div>

<script>
    document.getElementById('parent').addEventListener('click', () => {
        alert('Клик на родительском элементе! (Bubbling)');
    }); // Bubbling (по умолчанию)

    document.getElementById('parent').addEventListener('click', () => {
        alert('Клик на родительском элементе! (Capturing)');
    }, true); // Capturing

    document.getElementById('child').addEventListener('click', () => {
        alert('Клик на дочернем элементе!');
    });
</script>
```

При нажатии на кнопку сработает сначала обработчик на родительском элементе для Capturing, затем обработчик под ним (дочерний элемент), и, наконец, обработчик для родительского элемента для Bubbling.

**Резюме**

Event Bubbling и Event Capturing — это два подхода к распространению событий в DOM. В Bubbling событие всплывает от целевого элемента к родителям, а в Capturing происходит наоборот — событие погружается от родительских элементов к целевому. Оба метода позволяют создать гибкие обработчики событий на вложенных элементах.


#### Вопрос 42. Как остановить всплытие события?

В JavaScript вы можете остановить всплытие события, используя метод `stopPropagation()` объекта события. Это предотвращает дальнейшее распространение события вверх по дереву DOM после его обработки.

**Пример использования `stopPropagation()`**:

Рассмотрим сценарий, где у нас есть родительский элемент и дочерний элемент. Мы добавим обработчики событий для обоих элементов и остановим всплытие события, когда происходит клик на дочернем элементе.

**HTML и JavaScript код**:
```html
<div id="parent" style="padding: 20px; background-color: lightgray;">
    Родительский элемент
    <button id="child">Нажми меня!</button>
</div>

<script>
    // Обработчик для родительского элемента
    document.getElementById('parent').addEventListener('click', () => {
        alert('Клик на родительском элементе!');
    });

    // Обработчик для дочернего элемента
    document.getElementById('child').addEventListener('click', (event) => {
        alert('Клик на дочернем элементе!');
        event.stopPropagation(); // Остановить всплытие события
    });
</script>
```

**Что произойдет в этом примере?**

1. При нажатии на кнопку "Нажми меня!", сначала появится алерт "Клик на дочернем элементе!".
2. Затем, из-за вызова `event.stopPropagation()`, всплытие события будет остановлено, и обработчик клика на родительском элементе не сработает. Поэтому алерт "Клик на родительском элементе!" не появится.

**Дополнительный пример с различными событиями**:

Мы можем установить несколько обработчиков на разные события и также остановить всплытие.

**HTML и JavaScript код**:
```html
<div id="parent" style="padding: 20px; background-color: lightgray;">
    Родительский элемент
    <button id="child">Нажми меня!</button>
</div>

<script>
    // Обработчик для родительского элемента
    document.getElementById('parent').addEventListener('click', () => {
        alert('Клик на родительском элементе!');
    });

    // Обработчик для дочернего элемента с остановкой всплытия
    document.getElementById('child').addEventListener('click', (event) => {
        alert('Клик на дочернем элементе!');
        event.stopPropagation(); // Остановить всплытие события
    });

    // Обработчик для дочернего элемента на мышь
    document.getElementById('child').addEventListener('mouseover', () => {
        console.log('Наведение на дочерний элемент!');
    });
</script>
```

**Остановка всплытия при использовании делегирования событий**

Когда вы используете делегирование событий, у вас может возникнуть ситуация, когда вы хотите предотвратить выполнение родительских обработчиков событий, если клик был выполнен на дочернем элементе. 

```html
<ul id="list">
    <li>Пункт 1</li>
    <li>Пункт 2</li>
    <li>Пункт 3 <button class="button">Нажми меня!</button></li>
</ul>

<script>
    // Обработчик для списка
    document.getElementById('list').addEventListener('click', (event) => {
        alert('Клик на списке!');
    });

    // Обработчик для кнопки
    document.querySelector('.button').addEventListener('click', (event) => {
        alert('Кнопка нажата!');
        event.stopPropagation(); // Остановить всплытие события
    });
</script>
```

**Резюме**

Метод `stopPropagation()` позволяет остановить всплытие события вверх по дереву DOM, предотвращая выполнение других обработчиков событий на родительских элементах. Это полезно, когда вы хотите ограничить действия, которые должны произойти, когда пользователь взаимодействует с определенным элементом.


#### Вопрос 43. Что такое делегирование событий?

Делегирование событий — это подход в JavaScript, который позволяет добавить обработчик события на родительский элемент, а не на каждый дочерний элемент отдельно. Это особенно полезно, когда у вас есть множество элементов, которые могут динамически изменяться, например, в списках или таблицах.

Преимущества делегирования событий:

1. **Производительность**: Вместо добавления обработчиков на множество дочерних элементов, вы можете использовать один обработчик на родительском элементе, что снижает нагрузку на память.
2. **Динамическое добавление элементов**: Если вы добавляете новые элементы на страницу динамически (например, с помощью JavaScript), вам не нужно повторно связывать обработчики событий — родительский элемент уже настроен на обработку событий от новых дочерних элементов.

**Примеры делегирования событий**:

1. **Список элементов**

Рассмотрим пример, где у нас есть список `<ul>`, и мы хотим обрабатывать клики на каждом элементе списка `<li>`.

**HTML и JavaScript код**:
```html
<ul id="myList">
    <li>Элемент 1</li>
    <li>Элемент 2</li>
    <li>Элемент 3</li>
</ul>

<script>
    const list = document.getElementById('myList');

    // Добавляем обработчик события на родительский элемент
    list.addEventListener('click', (event) => {
        // Определяем, на какой элемент списка кликнули
        if (event.target.tagName === 'LI') {
            alert('Вы кликнули на: ' + event.target.textContent);
        }
    });
</script>
```

В этом примере, когда пользователь кликает на любой элемент списка, срабатывает один обработчик, который проверяет, действительно ли клик был по элементу `<li>`, и выводит соответствующее сообщение.

2. **Динамическое добавление элементов**

Теперь рассмотрим пример, где мы добавляем новые элементы списка динамически.

**HTML и JavaScript код**:
```html
<button id="addItem">Добавить элемент</button>
<ul id="myList"></ul>

<script>
    const list = document.getElementById('myList');
    const addItemButton = document.getElementById('addItem');
    let itemCount = 1;

    // Добавляем обработчик события на родительский элемент
    list.addEventListener('click', (event) => {
        if (event.target.tagName === 'LI') {
            alert('Вы кликнули на: ' + event.target.textContent);
        }
    });

    // Добавляем новые элементы в список
    addItemButton.addEventListener('click', () => {
        const newItem = document.createElement('li');
        newItem.textContent = 'Элемент ' + itemCount++;
        list.appendChild(newItem);
    });
</script>
```

В этом примере пользователь может добавлять новые элементы в список, и обработчик события продолжает работать для всех элементов, независимо от того, когда они были добавлены. Это демонстрирует основное преимущество делегирования событий.

3. **Таблица с делегированием событий**

Еще один пример — использование делегирования событий для обработки кликов в таблице.

**HTML и JavaScript код**:
```html
<table id="myTable">
    <tr>
        <th>Имя</th>
        <th>Возраст</th>
    </tr>
    <tr>
        <td>Алекс</td>
        <td>30</td>
    </tr>
    <tr>
        <td>Мария</td>
        <td>25</td>
    </tr>
</table>

<script>
    const table = document.getElementById('myTable');

    table.addEventListener('click', (event) => {
        // Проверяем, попали ли мы на ячейку (td)
        if (event.target.tagName === 'TD') {
            alert('Вы кликнули на ячейку со значением: ' + event.target.textContent);
        }
    });
</script>
```

Когда пользователь кликает внутри таблицы, срабатывает обработчик, который выводит значение ячейки, на которую был выполнен клик.

**Резюме**

Делегирование событий — это мощный подход, который позволяет эффективно управлять событиями у множества элементов, используя один обработчик на родительском элементе. Это повышает производительность и упрощает обработку событий у динамически добавляемых элементов.


#### Вопрос 44. Как динамически добавить класс элементу?

В JavaScript можно динамически добавлять классы к элементам, управляя их стилями. Для этого обычно используется метод `classList`, который предоставляет удобные методы для работы с классами CSS: `add()`, `remove()`, `toggle()` и `contains()`. Давайте рассмотрим, как это сделать с помощью различных примеров.

1. **Добавление класса с помощью `classList.add()`**

Используя метод `classList.add()`, вы можете добавить один или несколько классов к элементу.

**HTML и JavaScript код**:
```html
<button id="addClassButton">Добавить класс</button>
<div id="myElement" style="width: 100px; height: 100px; background-color: lightblue;"></div>

<script>
    const button = document.getElementById('addClassButton');
    const element = document.getElementById('myElement');

    button.addEventListener('click', () => {
        element.classList.add('newClass'); // Добавляем класс
    });
</script>

<style>
    .newClass {
        background-color: coral; /* Меняет цвет фона на коралловый */
        width: 200px; /* Изменяет ширину */
        height: 200px; /* Изменяет высоту */
    }
</style>
```

В этом примере, когда вы нажмёте на кнопку, класс `newClass` будет добавлен к элементу `div`, что изменит его стили.

2. **Удаление класса с помощью `classList.remove()`**

Если вам нужно удалить класс у элемента, вы можете использовать метод `classList.remove()`.

**HTML и JavaScript код**:
```html
<button id="removeClassButton">Удалить класс</button>
<div id="myElement" class="newClass" style="width: 200px; height: 200px; background-color: coral;"></div>

<script>
    const button = document.getElementById('removeClassButton');
    const element = document.getElementById('myElement');

    button.addEventListener('click', () => {
        element.classList.remove('newClass'); // Удаляем класс
    });
</script>
```

Когда вы нажмёте на кнопку, класс `newClass` будет удалён, и элемент вернётся к своим первоначальным стилям.

3. **Переключение класса с помощью `classList.toggle()`**

Метод `classList.toggle()` позволяет добавлять класс, если он отсутствует, или удалять его, если он уже присутствует.

**HTML и JavaScript код**:
```html
<button id="toggleClassButton">Переключить класс</button>
<div id="myElement" style="width: 100px; height: 100px; background-color: lightblue;"></div>

<script>
    const button = document.getElementById('toggleClassButton');
    const element = document.getElementById('myElement');

    button.addEventListener('click', () => {
        element.classList.toggle('newClass'); // Переключаем класс
    });
</script>

<style>
    .newClass {
        background-color: coral; /* Меняет цвет фона на коралловый */
        width: 200px; /* Изменяет ширину */
        height: 200px; /* Изменяет высоту */
    }
</style>
```

При нажатии на кнопку класс `newClass` будет добавлен или удален в зависимости от его текущего состояния.

4. **Добавление нескольких классов**

Метод `classList.add()` также может принимать несколько аргументов, чтобы добавить несколько классов одновременно.

**HTML и JavaScript код**:
```html
<button id="addMultipleClassesButton">Добавить несколько классов</button>
<div id="myElement" style="width: 100px; height: 100px; background-color: lightblue;"></div>

<script>
    const button = document.getElementById('addMultipleClassesButton');
    const element = document.getElementById('myElement');

    button.addEventListener('click', () => {
        element.classList.add('newClass', 'extraClass'); // Добавляем несколько классов
    });
</script>

<style>
    .newClass {
        background-color: coral; /* Меняет цвет фона на коралловый */
    }
    .extraClass {
        border: 2px solid red; /* Добавляет красную рамку */
    }
</style>
```

При нажатии на кнопку к элементу будут добавлены как `newClass`, так и `extraClass`, что изменит его стиль.

**Резюме**

Динамическое добавление классов к элементам в JavaScript можно легко реализовать с помощью методов `classList`. Эти методы позволяют добавлять, удалять и переключать классы, что удобно для управления стилями элементов на веб-странице. 


#### Вопрос 45. Как получить данные из input? 

В JavaScript вы можете получать данные из элемента `<input>` разными способами, используя его свойства и методы. Основной способ — это доступ к значению поля input с помощью свойства `value`. Давайте рассмотрим несколько примеров, как это сделать.

1. **Получение данных из текстового поля**

Следующий пример показывает, как получить значение из текстового поля `<input>` при нажатии на кнопку.

**HTML и JavaScript код**:
```html
<input type="text" id="myInput" placeholder="Введите текст" />
<button id="submitButton">Получить данные</button>
<p id="output"></p>

<script>
    const button = document.getElementById('submitButton');
    const input = document.getElementById('myInput');
    const output = document.getElementById('output');

    button.addEventListener('click', () => {
        const inputValue = input.value; // Получаем значение из input
        output.textContent = 'Вы ввели: ' + inputValue; // Показываем результат
    });
</script>
```

2. **Получение данных из радиокнопок**

В следующем примере мы получим значение из группы радиокнопок.

**HTML и JavaScript код**:
```html
<form id="myForm">
    <label>
        <input type="radio" name="color" value="red" /> Красный
    </label>
    <label>
        <input type="radio" name="color" value="green" /> Зеленый
    </label>
    <label>
        <input type="radio" name="color" value="blue" /> Синий
    </label>
    <button id="colorButton">Получить выбранный цвет</button>
</form>
<p id="output"></p>

<script>
    const button = document.getElementById('colorButton');
    const output = document.getElementById('output');

    button.addEventListener('click', (event) => {
        event.preventDefault(); // Предотвратить отправку формы
        const selectedColor = document.querySelector('input[name="color"]:checked'); // Получаем выбранный элемент
        if (selectedColor) {
            output.textContent = 'Вы выбрали цвет: ' + selectedColor.value; // Показываем выбранный цвет
        } else {
            output.textContent = 'Пожалуйста, выберите цвет.'; // Сообщение, если цвет не выбран
        }
    });
</script>
```

3. **Получение данных из флажков (checkbox)**

В этом примере мы покажем, как получить значения из нескольких флажков.

**HTML и JavaScript код**:
```html
<form id="myForm">
    <label>
        <input type="checkbox" name="hobby" value="reading" /> Чтение
    </label>
    <label>
        <input type="checkbox" name="hobby" value="sports" /> Спорт
    </label>
    <label>
        <input type="checkbox" name="hobby" value="music" /> Музыка
    </label>
    <button id="hobbyButton">Получить хобби</button>
</form>
<p id="output"></p>

<script>
    const button = document.getElementById('hobbyButton');
    const output = document.getElementById('output');

    button.addEventListener('click', (event) => {
        event.preventDefault(); // Предотвратить отправку формы
        const checkboxes = document.querySelectorAll('input[name="hobby"]:checked'); // Получаем отмеченные флажки
        const hobbies = Array.from(checkboxes).map(checkbox => checkbox.value); // Извлекаем значения
        output.textContent = 'Вы выбрали хобби: ' + (hobbies.length > 0 ? hobbies.join(', ') : 'ничего');
    });
</script>
```

4. **Получение данных из поля ввода с параметрами типа "password"**

Этот пример иллюстрирует получение значения из поля для ввода пароля.

**HTML и JavaScript код**:
```html
<input type="password" id="passwordInput" placeholder="Введите пароль" />
<button id="passwordButton">Получить пароль</button>
<p id="output"></p>

<script>
    const button = document.getElementById('passwordButton');
    const passwordInput = document.getElementById('passwordInput');
    const output = document.getElementById('output');

    button.addEventListener('click', () => {
        const passwordValue = passwordInput.value; // Получаем значение пароля
        output.textContent = 'Вы ввели пароль: ' + passwordValue; // Показываем пароль (в реальных приложениях избегайте этого!)
    });
</script>
```

**Резюме**

В JavaScript вы можете легко получать данные из различных типов полей ввода, таких как текстовые поля, радиокнопки, флажки и поля для ввода пароля, используя свойство `value`. Вы также можете использовать методы, такие как `querySelector` для получения значений из групповых элементов.

---

### ООП и паттерны

#### Вопрос 46. Что такое ООП? Какие принципы?  

Объектно-ориентированное программирование (ООП) — это парадигма программирования, основанная на концепции «объектов», которые представляют собой комбинацию данных (свойств или атрибутов) и функциональности (методов или поведения). ООП позволяет моделировать сложные системы, упрощая структуру программы и делая её более гибкой и понятной.

**Основные принципы ООП**:

1. **Инкапсуляция**: Это механизм, который объединяет данные и методы, работающие с этими данными, в один модуль (объект). Это позволяет скрывать внутренние детали реализации и защищать данные от несанкционированного доступа. В JavaScript инкапсуляция может быть достигнута через замыкания или использование классов.

   **Пример**:
   ```javascript
   class BankAccount {
       constructor(balance) {
           let _balance = balance; // Закрытое свойство

           this.getBalance = function() {
               return _balance; // Метод для доступа к закрытому свойству
           };

           this.deposit = function(amount) {
               if (amount > 0) {
                   _balance += amount;
               }
           };
       }
   }

   const account = new BankAccount(100);
   account.deposit(50);
   console.log(account.getBalance()); // 150
   ```

2. **Наследование**: Это механизм, который позволяет создавать новые классы (наследники) на основе уже существующих классов (родителей). Наследники могут наследовать свойства и методы родителя, а также добавлять свои собственные.

   **Пример**:
   ```javascript
   class Animal {
       constructor(name) {
           this.name = name;
       }

       speak() {
           console.log(`${this.name} издает звук.`);
       }
   }

   class Dog extends Animal { // Наследует от Animal
       speak() {
           console.log(`${this.name} гавкает.`);
       }
   }

   const dog = new Dog('Бобик');
   dog.speak(); // Бобик гавкает.
   ```

3. **Полиморфизм**: Это возможность использовать один и тот же интерфейс для работы с объектами различных типов. Полиморфизм позволяет методам одного класса переопределять методы других классов, что обеспечивает более гибкое поведение.

   **Пример**:
   ```javascript
   class Cat extends Animal {
       speak() {
           console.log(`${this.name} мяукает.`);
       }
   }

   const animals = [new Dog('Бобик'), new Cat('Мурка')];

   animals.forEach(animal => {
       animal.speak(); // Вызывает метод speak для каждого животного
   });

   // Бобик гавкает.
   // Мурка мяукает.
   ```

4. **Абстракция**: Это процесс выделения общих характеристик объектов и их поведения. Абстракция позволяет создавать abstract классы и интерфейсы, которые могут быть реализованы другими классами.

   **Пример**:
   ```javascript
   class Shape {
       area() {
           throw new Error("Метод area() должен быть реализован в подклассе.");
       }
   }

   class Circle extends Shape {
       constructor(radius) {
           super();
           this.radius = radius;
       }

       area() {
           return Math.PI * this.radius * this.radius;
       }
   }

   const circle = new Circle(5);
   console.log(circle.area()); // 78.53981633974483
   ```

**Резюме**

Объектно-ориентированное программирование (ООП) — это концепция, которая основывается на использовании объектов для структурирования кода. Основные принципы ООП включают инкапсуляцию, наследование, полиморфизм и абстракцию, что помогает улучшить читаемость, гибкость и переиспользование кода.



#### Вопрос 47. Как создать класс в JavaScript?

В JavaScript создание классов осуществляется с помощью синтаксиса классов, который был введён в ES6 (ECMAScript 2015). Классы представляют собой синтаксический сахар над функциями-конструкторами и позволяют использовать принципы объектно-ориентированного программирования. Давайте рассмотрим, как создать классы и как их использовать, через несколько примеров.

1. **Создание простого класса**

Создадим класс `Person`, который будет иметь свойства `name` и `age`, а также метод `introduce`, который будет выводить представление человека.

**HTML и JavaScript код**:
```html
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Пример класса в JavaScript</title>
</head>
<body>
    <script>
        class Person {
            constructor(name, age) {
                this.name = name;
                this.age = age;
            }

            introduce() {
                console.log(`Меня зовут ${this.name}, мне ${this.age} лет.`);
            }
        }

        const person1 = new Person('Александр', 30);
        person1.introduce(); // Меня зовут Александр, мне 30 лет.
    </script>
</body>
</html>
```

2. **Наследование классов**

Создадим класс `Student`, который наследует свойства и методы от класса `Person`. Также добавим новый метод `study`.

**HTML и JavaScript код**:
```html
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Наследование классов</title>
</head>
<body>
    <script>
        class Person {
            constructor(name, age) {
                this.name = name;
                this.age = age;
            }

            introduce() {
                console.log(`Меня зовут ${this.name}, мне ${this.age} лет.`);
            }
        }

        class Student extends Person {
            constructor(name, age, major) {
                super(name, age); // Вызываем конструктор родительского класса
                this.major = major;
            }

            study() {
                console.log(`${this.name} изучает ${this.major}.`);
            }
        }

        const student1 = new Student('Мария', 22, 'математику');
        student1.introduce(); // Меня зовут Мария, мне 22 лет.
        student1.study(); // Мария изучает математику.
    </script>
</body>
</html>
```

3. **Использование геттеров и сеттеров**

Геттеры и сеттеры позволяют нам выполнять блокировки доступа к свойствам объекта.

**HTML и JavaScript код**:
```html
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Геттеры и Сеттеры</title>
</head>
<body>
    <script>
        class Rectangle {
            constructor(width, height) {
                this.width = width;
                this.height = height;
            }

            get area() {
                return this.width * this.height;
            }

            set dimensions(dimensions) {
                this.width = dimensions.width;
                this.height = dimensions.height;
            }
        }

        const rect = new Rectangle(10, 5);
        console.log(`Площадь: ${rect.area}`); // Площадь: 50

        rect.dimensions = { width: 20, height: 10 };
        console.log(`Новая площадь: ${rect.area}`); // Новая площадь: 200
    </script>
</body>
</html>
```

4. **Статические методы**

Статические методы относятся не к экземплярам класса, а к самому классу. Они создаются с помощью ключевого слова `static`.

**HTML и JavaScript код**:
```html
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Статические методы</title>
</head>
<body>
    <script>
        class MathUtils {
            static add(a, b) {
                return a + b;
            }

            static multiply(a, b) {
                return a * b;
            }
        }

        console.log(MathUtils.add(5, 10)); // 15
        console.log(MathUtils.multiply(3, 4)); // 12
    </script>
</body>
</html>
```

**Резюме**

В JavaScript классы позволяют создавать объекты с заданными свойствами и методами, а также использовать принципы наследования, инкапсуляции и полиморфизма. Мы рассмотрели, как создать класс, реализовать наследование, использовать геттеры и сеттеры, а также статические методы. 


#### Вопрос 48. Что такое прототипное наследование?

Прототипное наследование — это один из основных механизмов, используемый в JavaScript для создания объектов и реализации наследования. В этом подходе объекты могут наследовать свойства и методы от других объектов через цепочку прототипов. Это означает, что когда вы пытаетесь получить доступ к свойству объекта, JavaScript сначала ищет его на самом объекте, а затем переходит к его прототипу и так далее, пока не найдет свойство или не достигнет конца цепочки (значение `null`).

1. **Прототипное наследование с использованием функции-конструктора**

Сначала создадим функцию-конструктор для создания объектов типа `Animal` и добавим в нее метод `speak`.

**JavaScript код**:
```javascript
function Animal(name) {
    this.name = name;
}

Animal.prototype.speak = function() {
    console.log(`${this.name} издает звук.`);
};

const dog = new Animal('Собака');
dog.speak(); // Собака издает звук.
```

2. **Наследование с помощью прототипов**

Теперь создадим новый тип `Dog`, который наследует свойства и методы от `Animal`.

**JavaScript код**:
```javascript
function Animal(name) {
    this.name = name;
}

Animal.prototype.speak = function() {
    console.log(`${this.name} издает звук.`);
};

function Dog(name) {
    Animal.call(this, name); // Вызываем конструктор родителя
}

// Настраиваем прототипы для наследования
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

// Добавляем метод, специфичный для Dog
Dog.prototype.speak = function() {
    console.log(`${this.name} гавкает.`);
};

const dog = new Dog('Бобик');
dog.speak(); // Бобик гавкает.
```

3. **Прототипная цепочка**

В этом примере мы покажем, как работает прототипная цепочка. Создадим базовый объект и объекты, которые наследуются от него.

**JavaScript код**:
```javascript
const animal = {
    speak: function() {
        console.log('Животное издает звук.');
    }
};

const dog = Object.create(animal); // Создаем dog с прототипом animal
dog.speak(); // Животное издает звук.

dog.bark = function() {
    console.log('Гав, гав!');
};

dog.bark(); // Гав, гав!
```

4. **Прототипы и методы**

Вы можете добавлять методы в прототипы и вызывать их у объектов.

**JavaScript код**:
```javascript
const vehicle = {
    start: function() {
        console.log('Автомобиль запускается!');
    }
};

const car = Object.create(vehicle); // Создаем car с прототипом vehicle
car.start(); // Автомобиль запускается!

vehicle.stop = function() {
    console.log('Автомобиль останавливается!');
};

car.stop(); // Автомобиль останавливается!
```

**Резюме**

Прототипное наследование в JavaScript позволяет создавать цепочки объектов, где один объект может наследовать свойства и методы от другого. Это дает возможность переиспользовать код и расширять функциональность. Мы рассмотрели, как создать функции-конструкторы, использовать прототипы для наследования и работать с прототипными цепочками.


#### Вопрос 49. Как работает `extends` и `super`?

`extends` и `super` — это ключевые слова, используемые в JavaScript для работы с классами и их наследованием. Они являются частью синтаксиса ES6 (ECMAScript 2015) и позволяют легче создавать наследуемые классы и вызывать родительские методы. Давайте подробнее рассмотрим, как они работают, с примерами.

1. **`extends`**

Ключевое слово `extends` используется для создания класса, который наследует от другого класса. Это позволяет дочернему классу получать все свойства и методы родительского класса.

**Пример с использованием `extends`**:
```javascript
class Animal {
    constructor(name) {
        this.name = name;
    }

    speak() {
        console.log(`${this.name} издает звук.`);
    }
}

// Класс Dog наследует от класса Animal
class Dog extends Animal {
    speak() {
        // Переопределяем метод speak для Dog
        console.log(`${this.name} гавкает.`);
    }
}

const dog = new Dog('Бобик');
dog.speak(); // Бобик гавкает.
```

2. **`super`**

Ключевое слово `super` используется для вызова конструкторов и методов родительского класса. Оно позволяет обращаться к родительскому классу из дочернего, и это полезно в случае, если вам нужно вызвать конструктор родительского класса или получить доступ к его методам.

**Пример с использованием `super` в конструкторе**:
```javascript
class Animal {
    constructor(name) {
        this.name = name;
    }

    speak() {
        console.log(`${this.name} издает звук.`);
    }
}

// Класс Cat наследует от класса Animal
class Cat extends Animal {
    constructor(name, color) {
        super(name); // Вызываем конструктор родительского класса
        this.color = color;
    }

    speak() {
        super.speak(); // Вызываем метод speak родительского класса
        console.log(`${this.name} мяукает.`);
    }
}

const cat = new Cat('Мурка', 'черный');
cat.speak(); 
// Мурка издает звук.
// Мурка мяукает.
```

**Пример с использованием `super` для методов**:

Также можно использовать `super` для вызова методов родительского класса, как показано ниже:

```javascript
class Vehicle {
    start() {
        console.log('Транспортное средство запускается.');
    }
}

class Car extends Vehicle {
    start() {
        super.start(); // Вызов метода start родительского класса
        console.log('Автомобиль готов к движению.');
    }
}

const car = new Car();
car.start();
// Транспортное средство запускается.
// Автомобиль готов к движению.
```

**Резюме**

- `extends` позволяет создавать новый класс, который наследует свойства и методы другого класса.
- `super` используется для вызова конструктора и методов родительского класса, что позволяет дочернему классу использовать, расширять или переопределять функциональность родителя.

Таким образом, `extends` и `super` делают объектно-ориентированное программирование в JavaScript более выразительным и удобным для работы. 


#### Вопрос 50. Что такое инкапсуляция, наследование, полиморфизм?

Инкапсуляция, наследование и полиморфизм — это три основные концепции объектно-ориентированного программирования (ООП). Давайте разберем каждую из этих концепций с примерами на JavaScript.

1. **Инкапсуляция**

Инкапсуляция — это механизм, который объединяет данные (свойства объекта) и методы (функции), работающие с этими данными, в одном модуле (объекте). Инкапсуляция также включает в себя скрытие внутренней реализации объекта от внешнего мира и предоставление публичного интерфейса.

В JavaScript инкапсуляцию можно реализовать, используя замыкания или, начиная с ES6, классы с приватными полями.

**Пример с использованием классов и приватных полей (ES2022)**:
```javascript
class BankAccount {
    #balance; // Приватное поле

    constructor(initialBalance) {
        this.#balance = initialBalance;
    }

    // Метод для получения баланса
    getBalance() {
        return this.#balance;
    }

    // Метод для пополнения счета
    deposit(amount) {
        if (amount > 0) {
            this.#balance += amount;
        }
    }
}

const account = new BankAccount(100);
account.deposit(50);
console.log(account.getBalance()); // 150
// console.log(account.#balance); // Ошибка, доступ к приватному полю запрещен
```

2. **Наследование**

Наследование — это механизм, позволяющий создавать новый класс на основе уже существующего. Новый класс (наследник) может наследовать свойства и методы родительского класса, а также добавлять свои собственные.

**Пример наследования**:
```javascript
class Animal {
    constructor(name) {
        this.name = name;
    }

    speak() {
        console.log(`${this.name} издает звук.`);
    }
}

// Класс Dog наследует от класса Animal
class Dog extends Animal {
    speak() {
        console.log(`${this.name} гавкает.`);
    }
}

const dog = new Dog('Бобик');
dog.speak(); // Бобик гавкает.
```

3. **Полиморфизм**

Полиморфизм — это возможность использования одного интерфейса для работы с объектами различных типов. Это дает возможность переопределять методы в дочерних классах и обеспечивать различное поведение в зависимости от типа объекта.

**Пример полиморфизма**:
```javascript
class Animal {
    speak() {
        console.log('Животное издает звук.');
    }
}

class Dog extends Animal {
    speak() {
        console.log('Собака гавкает.');
    }
}

class Cat extends Animal {
    speak() {
        console.log('Кошка мяукает.');
    }
}

const animals = [new Dog(), new Cat()];

animals.forEach(animal => {
    animal.speak(); // Вызываем метод speak для каждого животного
});
// Собака гавкает.
// Кошка мяукает.
```

**Резюме**

- **Инкапсуляция** обеспечивает скрытие данных и объединение состояния и поведения объекта.
- **Наследование** позволяет создавать новые классы на основе существующих, переиспользуя их свойства и методы.
- **Полиморфизм** позволяет использовать один интерфейс для различных объектов, обеспечивая адаптивное поведение.

Эти концепции делают код более модульным, легким для понимания и повторного использования. 



