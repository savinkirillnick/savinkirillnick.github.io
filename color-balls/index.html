<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color balls</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #000;
            padding: 20px;
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        .game-info {
            display: flex;
            justify-content: space-between;
            width: 350px;
            margin-bottom: 10px;
        }
        
        .score {
            font-size: 18px;
            font-weight: bold;
        }
        
        .game-board {
            display: grid;
            grid-template-columns: repeat(7, 50px);
            grid-template-rows: repeat(7, 50px);
            gap: 2px;
            background-color: #222;
            padding: 5px;
            border-radius: 5px;
            position: relative; /* Добавлено для корректного позиционирования */
        }
        
        .cell {
            width: 50px;
            height: 50px;
            background-color: #444;
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
        }
        
        .ball {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            transition: all 0.3s ease;
        }
        
        .next-ball {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            transition: all 0.3s ease;
        }
        .selected {
            box-shadow: 0 0 2px 2px white;
        }
        
        .controls {
            margin-top: 20px;
        }
        
        button {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }

        /* Стиль для анимированного перемещения */
        .ball-moving {
            position: absolute;
            z-index: 10;
            transition: all 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>Цветные шарики</h1>
        
        <div class="game-info">
            <div class="score">Очки: <span id="score">0</span></div>
            <div class="moves">Ход: <span id="move-count">0</span></div>
        </div>
        
        <div class="game-board" id="game-board"></div>
        
        <div class="controls">
            <button id="restart-btn">Новая игра</button>
        </div>
    </div>
    
    <div class="game-over" id="game-over">
        <h2>Игра окончена!</h2>
        <p>Ваш счет: <span id="final-score">0</span></p>
        <button onclick="restartGame()">Играть снова</button>
    </div>

    <script>
        const BOARD_SIZE = 7;
        
        const COLORS = [
            '#FF3333', // Насыщенный красный
            '#3366FF', // Насыщенный синий
            '#FFCC00', // Насыщенный желтый
            '#33CC33', // Насыщенный зеленый
            '#9933FF', // Насыщенный фиолетовый
            '#FF6600'  // Насыщенный оранжевый
                ];
        
        let gameBoard = [];
        let selectedBall = null;
        let score = 0;
        let moveCount = 0;
        let gameActive = true;
        let nextBalls = [];

        // Инициализация игры
        function initGame() {
            const boardElement = document.getElementById('game-board');
            boardElement.innerHTML = '';
            gameBoard = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null));
            
            // Создаем ячейки поля
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.addEventListener('click', handleCellClick);
                    boardElement.appendChild(cell);
                }
            }
            
            score = 0;
            moveCount = 0;
            gameActive = true;
            updateScore();
            document.getElementById('game-over').style.display = 'none';
            
            findNexBalls();
            // Добавляем начальные шарики
            addNewBalls();
        }

        function findNexBalls() {
            nextBalls = [];
            const emptyCells = [];
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    if (gameBoard[row][col] === null) {
                        emptyCells.push({row, col});
                    }
                }
            }
            
            if (emptyCells.length < 1) {
                endGame();
                return;
            }
            
            // Выбираем 3 случайные пустые ячейки
            for (let i = 0; i < 3; i++) {
                if (emptyCells.length === 0) break;
                
                const randomIndex = Math.floor(Math.random() * emptyCells.length);
                const {row, col} = emptyCells.splice(randomIndex, 1)[0];
                
                const colorIndex = Math.floor(Math.random() * COLORS.length);
                nextBalls.push({row, col, colorIndex});
            }
        }

        // Добавление новых шариков
        function addNewBalls() {
            if (!gameActive) return;
            
            let emptyCells = 0;
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    if (gameBoard[row][col] === null) {
                        emptyCells += 1;
                    }
                }
            }
            
            if (emptyCells < 3) {
                endGame();
                return;
            }
            
            // Ставим шарики из предыдущего набора
            for (let i = 0; i < nextBalls.length; i++) {
                const {row, col, colorIndex} = nextBalls[i];

                if (gameBoard[row][col] === null) {
                    // Очищаем ячейку от будущих шариков
                    const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                    // Очищаем ячейку перед добавлением нового шарика
                    cell.innerHTML = '';

                    gameBoard[row][col] = colorIndex;
                    createBall(row, col, colorIndex);
                }
            }
            
            findNexBalls();
            createNextBall();

            // Проверяем совпадения перед увеличением счетчика ходов
            if (!checkMatches()) {
                moveCount++;
                document.getElementById('move-count').textContent = moveCount;
                
                // Проверяем, не заполнено ли все поле
                if (isBoardFull()) {
                    endGame();
                }
            }
        }

        //Отображение на поле шариков из будущего хода
        function createNextBall() {
            for (let i = 0; i < nextBalls.length; i++) {
                const {row, col, colorIndex} = nextBalls[i];
                const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                // Очищаем ячейку перед добавлением нового шарика
                cell.innerHTML = '';
                const ball = document.createElement('div');
                ball.className = 'next-ball';
                ball.style.backgroundColor = COLORS[colorIndex];
                cell.appendChild(ball);
            }
        }

        // Создание шарика
        function createBall(row, col, colorIndex) {
            const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
            // Очищаем ячейку перед добавлением нового шарика
            cell.innerHTML = '';
            const ball = document.createElement('div');
            ball.className = 'ball';
            ball.style.backgroundColor = COLORS[colorIndex];
            cell.appendChild(ball);
        }

        // Обработка клика по ячейке
        function handleCellClick(event) {
            if (!gameActive) return;
            
            const row = parseInt(event.currentTarget.dataset.row);
            const col = parseInt(event.currentTarget.dataset.col);
            
            // Если ячейка содержит шарик
            if (gameBoard[row][col] !== null) {
                // Снимаем выделение с предыдущего шарика
                if (selectedBall) {
                    document.querySelector('.selected')?.classList.remove('selected');
                }
                
                // Выделяем новый шарик
                selectedBall = {row, col};
                event.currentTarget.classList.add('selected');
            }
            // Если ячейка пустая и есть выделенный шарик
            else if (selectedBall) {
                // Проверяем, можно ли переместить шарик
                const path = findPath(selectedBall.row, selectedBall.col, row, col);
                if (path) {
                    moveBall(selectedBall.row, selectedBall.col, row, col);
                    document.querySelector('.selected')?.classList.remove('selected');
                    selectedBall = null;
                }
            }
        }

        // Поиск пути перемещения (возвращает путь или null)
        function findPath(fromRow, fromCol, toRow, toCol) {
            // Используем алгоритм поиска в ширину для нахождения пути
            const queue = [{row: fromRow, col: fromCol, path: []}];
            const visited = new Set();
            visited.add(`${fromRow},${fromCol}`);
            
            const directions = [
                {dr: -1, dc: 0}, // вверх
                {dr: 1, dc: 0},  // вниз
                {dr: 0, dc: -1}, // влево
                {dr: 0, dc: 1}   // вправо
            ];
            
            while (queue.length > 0) {
                const current = queue.shift();
                
                if (current.row === toRow && current.col === toCol) {
                    return current.path; // Возвращаем весь путь
                }
                
                for (const dir of directions) {
                    const newRow = current.row + dir.dr;
                    const newCol = current.col + dir.dc;
                    const key = `${newRow},${newCol}`;
                    
                    if (newRow >= 0 && newRow < BOARD_SIZE && 
                        newCol >= 0 && newCol < BOARD_SIZE && 
                        !visited.has(key) && 
                        (gameBoard[newRow][newCol] === null || 
                        (newRow === fromRow && newCol === fromCol))) {
                        
                        visited.add(key);
                        queue.push({
                            row: newRow,
                            col: newCol,
                            path: [...current.path, {row: newRow, col: newCol}] // Сохраняем путь
                        });
                    }
                }
            }
            
            return null; // Путь не найден
        }

        // Проверка возможности перемещения (обертка для совместимости)
        function isValidMove(fromRow, fromCol, toRow, toCol) {
            return findPath(fromRow, fromCol, toRow, toCol) !== null;
        }

        // Перемещение шарика по пути
        function moveBall(fromRow, fromCol, toRow, toCol) {
            const path = findPath(fromRow, fromCol, toRow, toCol);
            if (!path) return;
            
            const colorIndex = gameBoard[fromRow][fromCol];
            gameBoard[fromRow][fromCol] = null;
            
            // Получаем элементы DOM
            const fromCell = document.querySelector(`.cell[data-row="${fromRow}"][data-col="${fromCol}"]`);
            const ball = fromCell.querySelector('.ball');
            
            // Создаем клон шарика для анимации
            const movingBall = ball.cloneNode(true);
            movingBall.classList.add('ball-moving');
            
            // Позиционируем шарик для анимации
            const boardRect = document.getElementById('game-board').getBoundingClientRect();
            
            movingBall.style.position = 'absolute';
            movingBall.style.width = `${ball.offsetWidth}px`;
            movingBall.style.height = `${ball.offsetHeight}px`;
            
            document.getElementById('game-board').appendChild(movingBall);
            
            // Скрываем оригинальный шарик
            ball.style.visibility = 'hidden';
            
            // Функция для анимации перемещения по точкам пути
            function animateAlongPath(pathPoints, currentIndex = 0) {
                if (currentIndex >= pathPoints.length) {
                    // Анимация завершена
                    completeMove();
                    return;
                }
                
                const point = pathPoints[currentIndex];
                const cell = document.querySelector(`.cell[data-row="${point.row}"][data-col="${point.col}"]`);
                const cellRect = cell.getBoundingClientRect();
                
                // Плавное перемещение к следующей точке
                movingBall.style.left = `${cellRect.left - boardRect.left}px`;
                movingBall.style.top = `${cellRect.top - boardRect.top}px`;
                
                // Рекурсивно вызываем для следующей точки с задержкой
                setTimeout(() => {
                    animateAlongPath(pathPoints, currentIndex + 1);
                }, 50); // Задержка между перемещениями к следующим точкам
            }
            
            // Функция завершения перемещения
            function completeMove() {
                // Устанавливаем шарик в целевую ячейку
                gameBoard[toRow][toCol] = colorIndex;
                
                // Удаляем анимированный шарик
                document.getElementById('game-board').removeChild(movingBall);
                
                // Удаляем оригинальный шарик
                fromCell.removeChild(ball);
                
                // Создаем шарик в новой ячейке
                createBall(toRow, toCol, colorIndex);
                
                addNewBalls();
            }
            
            // Начинаем анимацию с начальной позиции
            const fullPath = [{row: fromRow, col: fromCol}, ...path];
            animateAlongPath(fullPath);
        }

        // Проверка совпадений (3+ шариков одного цвета)
        function checkMatches() {
            const matches = [];
            
            // Проверка по горизонтали
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE - 2; col++) {
                    if (gameBoard[row][col] !== null &&
                        gameBoard[row][col] === gameBoard[row][col + 1] &&
                        gameBoard[row][col] === gameBoard[row][col + 2]) {
                        
                        let length = 3;
                        while (col + length < BOARD_SIZE && 
                               gameBoard[row][col + length] === gameBoard[row][col]) {
                            length++;
                        }
                        
                        for (let i = 0; i < length; i++) {
                            matches.push({row, col: col + i});
                        }
                    }
                }
            }
            
            // Проверка по вертикали
            for (let col = 0; col < BOARD_SIZE; col++) {
                for (let row = 0; row < BOARD_SIZE - 2; row++) {
                    if (gameBoard[row][col] !== null &&
                        gameBoard[row][col] === gameBoard[row + 1][col] &&
                        gameBoard[row][col] === gameBoard[row + 2][col]) {
                        
                        let length = 3;
                        while (row + length < BOARD_SIZE && 
                               gameBoard[row + length][col] === gameBoard[row][col]) {
                            length++;
                        }
                        
                        for (let i = 0; i < length; i++) {
                            matches.push({row: row + i, col});
                        }
                    }
                }
            }
            
            // Проверка по диагонали (сверху-слева направо-вниз)
            for (let row = 0; row < BOARD_SIZE - 2; row++) {
                for (let col = 0; col < BOARD_SIZE - 2; col++) {
                    if (gameBoard[row][col] !== null &&
                        gameBoard[row][col] === gameBoard[row + 1][col + 1] &&
                        gameBoard[row][col] === gameBoard[row + 2][col + 2]) {
                        
                        let length = 3;
                        while (row + length < BOARD_SIZE && 
                            col + length < BOARD_SIZE && 
                            gameBoard[row + length][col + length] === gameBoard[row][col]) {
                            length++;
                        }
                        
                        for (let i = 0; i < length; i++) {
                            matches.push({row: row + i, col: col + i});
                        }
                    }
                }
            }
            
            // Проверка по диагонали (сверху-справа налево-вниз)
            for (let row = 0; row < BOARD_SIZE - 2; row++) {
                for (let col = 2; col < BOARD_SIZE; col++) {
                    if (gameBoard[row][col] !== null &&
                        gameBoard[row][col] === gameBoard[row + 1][col - 1] &&
                        gameBoard[row][col] === gameBoard[row + 2][col - 2]) {
                        
                        let length = 3;
                        while (row + length < BOARD_SIZE && 
                            col - length >= 0 && 
                            gameBoard[row + length][col - length] === gameBoard[row][col]) {
                            length++;
                        }
                        
                        for (let i = 0; i < length; i++) {
                            matches.push({row: row + i, col: col - i});
                        }
                    }
                }
            }

            // Удаляем дубликаты
            const uniqueMatches = matches.filter((match, index, self) =>
                index === self.findIndex(m => m.row === match.row && m.col === match.col)
            );
            
            // Удаляем совпадающие шарики
            if (uniqueMatches.length > 0) {
                uniqueMatches.forEach(({row, col}) => {
                    gameBoard[row][col] = null;
                    const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                    // Полностью очищаем ячейку
                    cell.innerHTML = '';
                });
                
                // Добавляем очки
                score += uniqueMatches.length * 10;
                updateScore();
                
                return true; // Найдены совпадения
            }
            
            return false; // Совпадений не найдено
        }

        // Проверка, заполнено ли все поле
        function isBoardFull() {
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    if (gameBoard[row][col] === null) {
                        return false;
                    }
                }
            }
            return true;
        }

        // Обновление счета
        function updateScore() {
            document.getElementById('score').textContent = score;
        }

        // Конец игры
        function endGame() {
            gameActive = false;
            document.getElementById('final-score').textContent = score;
            document.getElementById('game-over').style.display = 'block';
        }

        // Перезапуск игры
        function restartGame() {
            initGame();
        }

        // Инициализация игры при загрузке
        document.addEventListener('DOMContentLoaded', () => {
            initGame();
            document.getElementById('restart-btn').addEventListener('click', restartGame);
        });
    </script>
</body>
</html>
